// This is automatically generated code -- do not edit!
// Generated from  
#include <vector>
namespace skeletons
{


  const char * WCartesianChart_js1 = "/*\r\n"
  " * Copyright (C) 2015 Emweb bv, Herent, Belgium.\r\n"
  " *\r\n"
  " * See the LICENSE file for terms of use.\r\n"
  " */\r\n"
  "\r\n"
  "/* Note: this is at the same time valid JavaScript and C++. */\r\n"
  "\r\n"
  "WT_DECLARE_WT_MEMBER_BIG\r\n"
  "(1, JavaScriptConstructor, \"WCartesianChart\",\r\n"
  "  // target: the WPaintedWidget JavaScript obj, with:\r\n"
  "  //   repaint\r\n"
  "  //   canvas\r\n"
  "  //   combinedTransform is set by WCartesianChart\r\n"
  "  // config: the initial configuration (can be overridden with updateConfig)\r\n"
  "  //   curveManipulation (determines whether series manipulation is enabled)\r\n"
  "  //   seriesSelection (determines whether series selection is enabled)\r\n"
  "  //   selectedCurve (the curve that is currently selected)\r\n"
  "  //   isHorizontal (if orientation() == Horizontal)\r\n"
  "  //   xTransforms[]\r\n"
  "  //   yTransforms[]\r\n"
  "  //   area (WRectF describing render area)\r\n"
  "  //   insideArea (WRectF describing render area without axis margins)\r\n"
  "  //   xModelAreas ([WRectF] describing model areas per X axis)\r\n"
  "  //   yModelAreas ([WRectF] describing model areas per Y axis)\r\n"
  "  //   minZoom {x: [float], y: [float]}\r\n"
  "  //   maxZoom {x: [float], y: [float]}\r\n"
  "  //   rubberBand\r\n"
  "  //   zoom (bool)\r\n"
  "  //   pan (bool)\r\n"
  "  //   crosshair (bool)\r\n"
  "  //   crosshairXAxis (int)\r\n"
  "  //   crosshairYAxis (int)\r\n"
  "  //   crosshairColor (css text)\r\n"
  "  //   followCurve (int, -1 for disabled)\r\n"
  "  //   notifyTransform {x: [bool], y: [bool]} // Whether we should emit a signal on X or Y transform change\r\n"
  "  //   series {modelColumn: {curve: curve ref, transform: transform ref, xAxis: int, yAxis: int},...}\r\n"
  "  //   ToolTipInnerStyle // Style for the tooltip\r\n"
  "  //   ToolTipOuterStyle // Style for the tooltip\r\n"
  "  //   hasToolTips // whether there are any tooltips\r\n"
  "  //   pens // {x: [[linePen,textPen,gridPen],...], y: [[linePen,textPen,gridPen],...] }\r\n"
  "  //   penAlpha: {x: [[linePenAlpha,textPenAlpha,gridPenAlpha],...], y: [[linePenAlpha,textPenAlpha,gridPenAlpha],...] }\r\n"
  "  //   xAxes: [{width: float, side: side, minOffset: float, maxOffset: float}] side = min max zero both\r\n"
  "  //   yAxes: [{width: float, side: side, minOffset: float, maxOffset: float}] side = min max zero both\r\n"
  "  //\r\n"
  "  function(APP, widget, target, config) {\r\n"
  "\r\n"
  "    widget.wtCObj = this;\r\n"
  "\r\n"
  "    var self = this;\r\n"
  "    var WT = APP.WT;\r\n"
  "\r\n"
  "    self.config = config;\r\n"
  "\r\n"
  "    var utils = WT.gfxUtils;\r\n"
  "    var mult = utils.transform_mult;\r\n"
  "    var inverted = utils.transform_inverted;\r\n"
  "    var assign = utils.transform_assign;\r\n"
  "    var equal = utils.transform_equal;\r\n"
  "    var apply = utils.transform_apply;\r\n"
  "    var top = utils.rect_top;\r\n"
  "    var bottom = utils.rect_bottom;\r\n"
  "    var left = utils.rect_left;\r\n"
  "    var right = utils.rect_right;\r\n"
  "    var intersection = utils.rect_intersection;\r\n"
  "\r\n"
  "    var chartCommon = WT.chartCommon;\r\n"
  "    var minMaxY = chartCommon.minMaxY;\r\n"
  "    var findClosestPoint = chartCommon.findClosestPoint;\r\n"
  "    var projection = chartCommon.projection;\r\n"
  "    var distanceLessThanRadius = chartCommon.distanceLessThanRadius;\r\n"
  "    var toZoomLevel = chartCommon.toZoomLevel;\r\n"
  "    var isPointInRect = chartCommon.isPointInRect;\r\n"
  "    var findYRange = chartCommon.findYRange;\r\n"
  "    var matchXAxis = function(x,y) {\r\n"
  "      return chartCommon.matchXAxis(x, y, configArea(), config.xAxes, isHorizontal());\r\n"
  "    };\r\n"
  "    var matchYAxis = function(x,y) {\r\n"
  "      return chartCommon.matchYAxis(x, y, configArea(), config.yAxes, isHorizontal());\r\n"
  "    };\r\n"
  "\r\n"
  "    // Functions that help in making minification more effective\r\n"
  "    function isUndefined(x) {\r\n"
  "      return x === undefined;\r\n"
  "    }\r\n"
  "    function xModelArea(ax) { return config.xModelAreas[ax]; }\r\n"
  "    function yModelArea(ax) { return config.yModelAreas[ax]; }\r\n"
  "    function modelArea(xAx, yAx) {\r\n"
  "      var xArea = xModelArea(xAx);\r\n"
  "      var yArea = yModelArea(yAx);\r\n"
  "      if (isHorizontal()) {\r\n"
  "        return [yArea[0], xArea[1], yArea[2], xArea[3]];\r\n"
  "      } else {\r\n"
  "        return [xArea[0], yArea[1], xArea[2], yArea[3]];\r\n"
  "      }\r\n"
  "    }\r\n"
  "    function followCurve() { return config.followCurve; }\r\n"
  "    function showCrosshair() {\r\n"
  "      return config.crosshair || followCurve() !== -1;\r\n"
  "    }\r\n"
  "    function isHorizontal() { return config.isHorizontal; }\r\n"
  "    function xTransform(ax) {\r\n"
  "      return config.xTransforms[ax];\r\n"
  "    }\r\n"
  "    function yTransform(ax) {\r\n"
  "      return config.yTransforms[ax];\r\n"
  "    }\r\n"
  "    function configArea() { return config.area; }\r\n"
  "    function insideArea() { return config.insideArea; }\r\n"
  "    function configSeries(seriesNb) {\r\n"
  "      if (!isUndefined(seriesNb)) {\r\n"
  "        return config.series[seriesNb];\r\n"
  "      } else {\r\n"
  "        return config.series;\r\n"
  "      }\r\n"
  "    }\r\n"
  "    function seriesTransform(seriesNb) {\r\n"
  "      return configSeries(seriesNb).transform;\r\n"
  "    }\r\n"
  "    function curveTransform(seriesNb) {\r\n"
  "      if (isHorizontal()) {\r\n"
  "        return mult([0,1,1,0,0,0], mult(seriesTransform(seriesNb), [0,1,1,0,0,0]));\r\n"
  "      } else {\r\n"
  "        return seriesTransform(seriesNb);\r\n"
  "      }\r\n"
  "    }\r\n"
  "    function seriesCurve(seriesNb) {\r\n"
  "      return configSeries(seriesNb).curve;\r\n"
  "    }\r\n"
  "    function seriesXAxis(seriesNb) {\r\n"
  "      return configSeries(seriesNb).xAxis;\r\n"
  "    }\r\n"
  "    function seriesYAxis(seriesNb) {\r\n"
  "      return configSeries(seriesNb).yAxis;\r\n"
  "    }\r\n"
  "    function seriesSelection() {\r\n"
  "      return config.seriesSelection;\r\n"
  "    }\r\n"
  "    function sliders() {\r\n"
  "      return config.sliders;\r\n"
  "    }\r\n"
  "    function hasToolTips() {\r\n"
  "      return config.hasToolTips;\r\n"
  "    }\r\n"
  "    function coordinateOverlayPadding() {\r\n"
  "      return config.coordinateOverlayPadding;\r\n"
  "    }\r\n"
  "    function curveManipulation() {\r\n"
  "      return config.curveManipulation;\r\n"
  "    }\r\n"
  "    function minXZoom(ax) {\r\n"
  "      return config.minZoom.x[ax];\r\n"
  "    }\r\n"
  "    function minYZoom(ax) {\r\n"
  "      return config.minZoom.y[ax];\r\n"
  "    }\r\n"
  "    function maxXZoom(ax) {\r\n"
  "      return config.maxZoom.x[ax];\r\n"
  "    }\r\n"
  "    function maxYZoom(ax) {\r\n"
  "      return config.maxZoom.y[ax];\r\n"
  "    }\r\n"
  "    function pens() {\r\n"
  "      return config.pens;\r\n"
  "    }\r\n"
  "    function penAlpha() {\r\n"
  "      return config.penAlpha;\r\n"
  "    }\r\n"
  "    function configSelectedCurve() {\r\n"
  "      return config.selectedCurve;\r\n"
  "    }\r\n"
  "    function preventDefault(e) {\r\n"
  "      if (e.preventDefault)\r\n"
  "        e.preventDefault();\r\n"
  "    }\r\n"
  "    function addEventListener(e,l) {\r\n"
  "      widget.addEventListener(e,l);\r\n"
  "    }\r\n"
  "    function removeEventListener(e,l) {\r\n"
  "      widget.removeEventListener(e,l);\r\n"
  "    }\r\n"
  "    function len(ar) {\r\n"
  "      return ar.length;\r\n"
  "    }\r\n"
  "    function xAxisCount() {\r\n"
  "      return len(config.xAxes);\r\n"
  "    }\r\n"
  "    function yAxisCount() {\r\n"
  "      return len(config.yAxes);\r\n"
  "    }\r\n"
  "    function notifyAnyTransform() {\r\n"
  "      for (var i = 0; i < xAxisCount(); ++i) {\r\n"
  "        if (config.notifyTransform.x[i])\r\n"
  "          return true;\r\n"
  "      }\r\n"
  "      for (var i = 0; i < yAxisCount(); ++i) {\r\n"
  "        if (config.notifyTransform.y[i])\r\n"
  "          return true;\r\n"
  "      }\r\n"
  "      return false;\r\n"
  "    }\r\n"
  "    function crosshairXAxis() {\r\n"
  "      return config.crosshairXAxis;\r\n"
  "    }\r\n"
  "    function crosshairYAxis() {\r\n"
  "      return config.crosshairYAxis;\r\n"
  "    }\r\n"
  "\r\n"
  "    /* const */ var ANIMATION_INTERVAL = 17;\r\n"
  "    var rqAnimFrame = (function(){\r\n"
  "      return window.requestAnimationFrame       ||\r\n"
  "        window.webkitRequestAnimationFrame ||\r\n"
  "        window.mozRequestAnimationFrame    ||\r\n"
  "        function(callback) {\r\n"
  "          window.setTimeout(callback, ANIMATION_INTERVAL);\r\n"
  "        };\r\n"
  "    })();\r\n"
  "    var framePending = false;\r\n"
  "    var rqAnimFrameThrottled = function(cb) {\r\n"
  "      if (framePending) return;\r\n"
  "      framePending = true;\r\n"
  "      rqAnimFrame(function() {\r\n"
  "        cb();\r\n"
  "        framePending = false;\r\n"
  "      });\r\n"
  "    };\r\n"
  "\r\n"
  "    if (window.MSPointerEvent || window.PointerEvent) {\r\n"
  "      widget.style.touchAction = 'none';\r\n"
  "      target.canvas.style.msTouchAction = 'none';\r\n"
  "      target.canvas.style.touchAction = 'none';\r\n"
  "    }\r\n"
  "\r\n"
  "    /*const*/ var NO_LIMIT = 1, DAMPEN = 2; // bit flags\r\n"
  "    /*const*/ var X_ONLY = 1, Y_ONLY = 2; // bit flags\r\n"
  "    /*const*/ var X = 0, Y = 1;\r\n"
  "    /*const*/ var LOOK_MODE = 0, CROSSHAIR_MODE = 1;\r\n"
  "    /*const*/ var WHEEL_ZOOM_X = 0, WHEEL_ZOOM_Y = 1, WHEEL_ZOOM_XY = 2,\r\n"
  "                  WHEEL_ZOOM_MATCHING = 3, WHEEL_PAN_X = 4, WHEEL_PAN_Y = 5,\r\n"
  "                  WHEEL_PAN_MATCHING = 6;\r\n"
  "\r\n"
  "    /*const*/ var SERIES_SELECTION_TIMEOUT = 200; // ms\r\n"
  "    /*const*/ var TRANSFORM_CHANGED_TIMEOUT = 250; // ms\r\n"
  "    /*const*/ var TOOLTIP_TIMEOUT = 500; // ms\r\n"
  "    /*const*/ var TOOLTIP_HIDE_DELAY = 200; // ms\r\n"
  "\r\n"
  "    /*const*/ var FRICTION_FACTOR = 0.003, // Determines how strongly the speed decreases, when animating\r\n"
  "                  SPRING_CONSTANT = 0.0002, // How strongly the spring pulls, relative to how extended it is\r\n"
  "                  RESISTANCE_FACTOR = 0.07, // How strongly the spring resists movement, when dragging\r\n"
  "                  BOUNDS_SLACK = 3, // The amount of slack to apply to determine whether an area is within bounds\r\n"
  "                  MIN_SPEED = 0.001, // The minimum speed that the animation should pan at when out of bounds,\r\n"
  "                                     // ensures that the animation does not stop prematurely.\r\n"
  "                  MAX_SPEED = 1.5, // The maximum speed that we should cap to, to prevent glitchy stuff\r\n"
  "                  STOPPING_SPEED = 0.02; // If the speed is below the stopping speed, and we're inside of bounds,\r\n"
  "                                         // then we can stop the animation.\r\n"
  "\r\n"
  "    // eobj2: an object to hold the context menu listener, that simply prevents the default behaviour,\r\n"
  "    //        so that a long press in order to select a series is not interpreted as a right click\r\n"
  "    var eobj2 = widget.wtEObj2;\r\n"
  "    if (!eobj2) {\r\n"
  "      eobj2 = {};\r\n"
  "      eobj2.contextmenuListener = function(e) {\r\n"
  "        preventDefault(e);\r\n"
  "        removeEventListener('contextmenu', eobj2.contextmenuListener);\r\n"
  "      };\r\n"
  "    }\r\n"
  "    widget.wtEObj2 = eobj2;\r\n"
  "\r\n"
  "    var touchHandlers = {};\r\n"
  "\r\n"
  "    function isTouchEvent(event) {\r\n"
  "      return event.pointerType === 2 || event.pointerType === 3 ||\r\n"
  "        event.pointerType === 'pen' || event.pointerType === 'touch';\r\n"
  "    }\r\n"
  "\r\n"
  "    var pointerActive = false;\r\n"
  "\r\n"
  "    if (window.MSPointerEvent || window.PointerEvent) {\r\n"
  "      (function(){\r\n"
  "        var pointers = []\r\n"
  "\r\n"
  "          function updatePointerActive() {\r\n"
  "            pointerActive = len(pointers) > 0;\r\n"
  "          }\r\n"
  "\r\n"
  "        function pointerDown(event) {\r\n"
  "          if (!isTouchEvent(event)) return;\r\n"
  "          preventDefault(event);\r\n"
  "          pointers.push(event);\r\n"
  "\r\n"
  "          updatePointerActive();\r\n"
  "          touchHandlers.start(widget, {touches:pointers.slice(0)});\r\n"
  "        }\r\n"
  "\r\n"
  "        function pointerUp(event) {\r\n"
  "          if (!pointerActive) return;\r\n"
  "          if (!isTouchEvent(event)) return;\r\n"
  "          preventDefault(event);\r\n"
  "          var i;\r\n"
  "          for (i = 0; i < len(pointers); ++i) {\r\n"
  "            if (pointers[i].pointerId === event.pointerId) {\r\n"
  "              pointers.splice(i, 1);\r\n"
  "              break;\r\n"
  "            }\r\n"
  "          }\r\n"
  "\r\n"
  "          updatePointerActive();\r\n"
  "          touchHandlers.end(widget, {touches:pointers.slice(0),changedTouches:[]});\r\n"
  "        }\r\n"
  "\r\n"
  "        function pointerMove(event) {\r\n"
  "          if (!isTouchEvent(event)) return;\r\n"
  "          preventDefault(event);\r\n"
  "          var i;\r\n"
  "          for (i = 0; i < len(pointers); ++i) {\r\n"
  "            if (pointers[i].pointerId === event.pointerId) {\r\n"
  "              pointers[i] = event;\r\n"
  "              break;\r\n"
  "            }\r\n"
  "          }\r\n"
  "\r\n"
  "          updatePointerActive();\r\n"
  "          touchHandlers.moved(widget, {touches:pointers.slice(0)});\r\n"
  "        }\r\n"
  "\r\n"
  "        // eobj: an object for holding the handlers so we can properly register/unregister them,\r\n"
  "        //       even when the chart gets updated\r\n"
  "        var o = widget.wtEObj;\r\n"
  "        if (o) {\r\n"
  "          if (!window.PointerEvent) {\r\n"
  "            removeEventListener('MSPointerDown', o.pointerDown);\r\n"
  "            removeEventListener('MSPointerUp', o.pointerUp);\r\n"
  "            removeEventListener('MSPointerOut', o.pointerUp);\r\n"
  "            removeEventListener('MSPointerMove', o.pointerMove);\r\n"
  "          } else {\r\n"
  "            removeEventListener('pointerdown', o.pointerDown);\r\n"
  "            removeEventListener('pointerup', o.pointerUp);\r\n"
  "            removeEventListener('pointerout', o.pointerUp);\r\n"
  "            removeEventListener('pointermove', o.pointerMove);\r\n"
  "          }\r\n"
  "        }\r\n"
  "        widget.wtEObj = {\r\n"
  "          pointerDown: pointerDown,\r\n"
  "          pointerUp: pointerUp,\r\n"
  "          pointerMove: pointerMove\r\n"
  "        };\r\n"
  "        if (!window.PointerEvent) {\r\n"
  "          addEventListener('MSPointerDown', pointerDown);\r\n"
  "          addEventListener('MSPointerUp', pointerUp);\r\n"
  "          addEventListener('MSPointerOut', pointerUp);\r\n"
  "          addEventListener('MSPointerMove', pointerMove);\r\n"
  "        } else {\r\n"
  "          addEventListener('pointerdown', pointerDown);\r\n"
  "          addEventListener('pointerup', pointerUp);\r\n"
  "          addEventListener('pointerout', pointerUp);\r\n"
  "          addEventListener('pointermove', pointerMove);\r\n"
  "        }\r\n"
  "      })();\r\n"
  "    }\r\n"
  "\r\n"
  "    // oobj: the <canvas> for drawing the crosshair\r\n"
  "    var overlay = widget.wtOObj;\r\n"
  "\r\n"
  "    var crosshair = null;\r\n"
  "\r\n"
  "    var paintEnabled = true; \r\n"
  "    var dragPreviousXY = null;\r\n"
  "    var dragCurrentXAxis = -1;\r\n"
  "    var dragCurrentYAxis = -1;\r\n"
  "    var touches = [];\r\n"
  "    var singleTouch = false;\r\n"
  "    var doubleTouch = false;\r\n"
  "    var zoomAngle = null;\r\n"
  "    var zoomMiddle = null;\r\n"
  "    var zoomProjection = null;\r\n"
  "\r\n"
  "    var v = {x: 0, y: 0};\r\n"
  "\r\n"
  "    var seriesSelectionTimeout = null;\r\n"
  "    var lastDate = null;\r\n"
  "\r\n"
  "    var tobj = widget.wtTObj;\r\n"
  "    if (!tobj) {\r\n"
  "      tobj = {overTooltip:false};\r\n"
  "      widget.wtTObj = tobj;\r\n"
  "    }\r\n"
  "\r\n"
  "    function hideTooltip() {\r\n"
  "      if (!tobj)\r\n"
  "        return;\r\n"
  "      if (tobj.tooltipTimeout) {\r\n"
  "        clearTimeout(tobj.tooltipTimeout);\r\n"
  "        tobj.tooltipTimeout = null;\r\n"
  "      }\r\n"
  "      if (tobj.overTooltip) {\r\n"
  "        return;\r\n"
  "      }\r\n"
  "      if (tobj.tooltipOuterDiv) {\r\n"
  "        document.body.removeChild(tobj.tooltipOuterDiv);\r\n"
  "        tobj.toolTipEl = null;\r\n"
  "        tobj.tooltipOuterDiv = null;\r\n"
  "      }\r\n"
  "    }\r\n"
  "\r\n"
  "    var mode = null;\r\n"
  "\r\n"
  "\r\n"
  "    var animating = false;\r\n"
  "\r\n"
  "    var transformChangedTimeout = null;\r\n"
  "    var oldXTransforms = [];\r\n"
  "    for (var i = 0; i < xAxisCount(); ++i) {\r\n"
  "      oldXTransforms.push([0,0,0,0,0,0]);\r\n"
  "      assign(oldXTransforms[i], xTransform(i));\r\n"
  "    }\r\n"
  "    var oldYTransforms = [];\r\n"
  "    for (var i = 0; i < yAxisCount(); ++i) {\r\n"
  "      oldYTransforms.push([0,0,0,0,0,0]);\r\n"
  "      assign(oldYTransforms[i], yTransform(i));\r\n"
  "    }\r\n"
  "    function setTransformChangedTimeout() {\r\n"
  "      if (!notifyAnyTransform())\r\n"
  "        return;\r\n"
  "      if (transformChangedTimeout) {\r\n"
  "        window.clearTimeout(transformChangedTimeout);\r\n"
  "        transformChangedTimeout = null;\r\n"
  "      }\r\n"
  "      transformChangedTimeout = setTimeout(function(){\r\n"
  "        for (var i = 0; i < xAxisCount(); ++i) {\r\n"
  "          if (config.notifyTransform.x[i] && !equal(oldXTransforms[i], xTransform(i))) {\r\n"
  "            APP.emit(target.widget, \"xTransformChanged\" + i);\r\n"
  "            assign(oldXTransforms[i], xTransform(i));\r\n"
  "          }\r\n"
  "        }\r\n"
  "        for (var i = 0; i < yAxisCount(); ++i) {\r\n"
  "          if (config.notifyTransform.y[i] && !equal(oldYTransforms[i], yTransform(i))) {\r\n"
  "            APP.emit(target.widget, \"yTransformChanged\" + i);\r\n"
  "            assign(oldYTransforms[i], yTransform(i));\r\n"
  "          }\r\n"
  "        }\r\n"
  "      }, TRANSFORM_CHANGED_TIMEOUT);\r\n"
  "    }\r\n"
  "    var tAssign = function(a, b) {\r\n"
  "      assign(a,b);\r\n"
  "      setTransformChangedTimeout();\r\n"
  "    }\r\n"
  "\r\n"
  "\r\n"
  "    function combinedTransform(xAx, yAx) {\r\n"
  "      if (xAx === undefined) {\r\n"
  "        xAx = 0;\r\n"
  "      }\r\n"
  "      if (yAx === undefined) {\r\n"
  "        yAx = 0;\r\n"
  "      }\r\n"
  "      var l, b, t;\r\n"
  "      if (isHorizontal()) {\r\n"
  "        l = left(configArea());\r\n"
  "        t = top(configArea());\r\n"
  "        return mult([0,1,1,0,l,t], mult(xTransform(xAx), mult(yTransform(yAx), [0,1,1,0,-t,-l])));\r\n"
  "      } else {\r\n"
  "        l = left(configArea());\r\n"
  "        b = bottom(configArea());\r\n"
  "        return mult([1,0,0,-1,l,b], mult(xTransform(xAx), mult(yTransform(yAx), [1,0,0,-1,-l,b])));\r\n"
  "      }\r\n"
  "    }\r\n"
  "    target.combinedTransform = combinedTransform;\r\n"
  "\r\n"
  "    function transformedInsideChartArea(xAx, yAx) {\r\n"
  "      return mult(combinedTransform(xAx, yAx), insideArea());\r\n"
  "    }\r\n"
  "\r\n"
  "\r\n"
  "    function toModelCoord(p, xAx, yAx, noTransform) {\r\n"
  "      if (isUndefined(noTransform)) noTransform = false;\r\n"
  "      var res;\r\n"
  "      if (noTransform) {\r\n"
  "        res = p;\r\n"
  "      } else {\r\n"
  "        res = mult(inverted(combinedTransform(xAx, yAx)), p);\r\n"
  "      }\r\n"
  "      var u;\r\n"
  "      if (isHorizontal()) {\r\n"
  "        u = [(res[Y] - configArea()[1]) / configArea()[3],\r\n"
  "          (res[X] - configArea()[0]) / configArea()[2]];\r\n"
  "      } else {\r\n"
  "        u = [(res[X] - configArea()[0]) / configArea()[2],\r\n"
  "          1 - (res[Y] - configArea()[1]) / configArea()[3]];\r\n"
  "      }\r\n"
  "      return [modelArea(xAx,yAx)[0] + u[X] * modelArea(xAx,yAx)[2],\r\n"
  "      modelArea(xAx,yAx)[1] + u[Y] * modelArea(xAx,yAx)[3]];\r\n"
  "    }\r\n"
  "\r\n"
  "    function toDisplayCoord(p, xAx, yAx, noTransform) {\r\n"
  "      if (isUndefined(noTransform))\r\n"
  "        noTransform = false;\r\n"
  "      return chartCommon.toDisplayCoord(p, noTransform ? [1,0,0,1,0,0] : combinedTransform(xAx,yAx), isHorizontal(), configArea(), modelArea(xAx,yAx));\r\n"
  "    }\r\n"
  "\r\n"
  "    function notifyAreaChanged() {\r\n"
  "      for (var xAx = 0; xAx < xAxisCount(); ++xAx) {\r\n"
  "        var u,v;\r\n"
  "        var area = modelArea(xAx, 0);\r\n"
  "        if (isHorizontal()) {\r\n"
  "          u = (toModelCoord([0, top(configArea())], xAx, 0)[0] - area[0]) / area[2];\r\n"
  "          v = (toModelCoord([0, bottom(configArea())], xAx, 0)[0] - area[0]) / area[2];\r\n"
  "        } else {\r\n"
  "          u = (toModelCoord([left(configArea()), 0], xAx, 0)[0] - area[0]) / area[2];\r\n"
  "          v = (toModelCoord([right(configArea()), 0], xAx, 0)[0] - area[0]) / area[2];\r\n"
  "        }\r\n"
  "        var i;\r\n"
  "        for (i = 0; i < len(sliders()); ++i) {\r\n"
  "          var o = $('#' + sliders()[i]);\r\n"
  "          if (o) {\r\n"
  "            var sobj = o.data('sobj');\r\n"
  "            if (sobj && sobj.xAxis === xAx) {\r\n"
  "              sobj.changeRange(u, v);\r\n"
  "            }\r\n"
  "          }\r\n"
  "        }\r\n"
  "      }\r\n"
  "    }\r\n"
  "\r\n"
  "    function repaint() {\r\n"
  "      hideTooltip();\r\n"
  "      if (hasToolTips() && tobj.tooltipPosition) {\r\n"
  "        tobj.tooltipTimeout = setTimeout(function() {\r\n"
  "          loadTooltip();\r\n"
  "        }, TOOLTIP_TIMEOUT);\r\n"
  "      }\r\n"
  "      if (!paintEnabled) return;\r\n"
  "      rqAnimFrameThrottled(function(){\r\n"
  "        target.repaint();\r\n"
  "        if (showCrosshair()) {\r\n"
  "          repaintOverlay();\r\n"
  "        }\r\n"
  "      });\r\n"
  "    }\r\n"
  "\r\n"
  "    function repaintOverlay() {\r\n"
  "      if (!paintEnabled) return;\r\n"
  "      var ctx = overlay.getContext('2d');\r\n"
  "\r\n"
  "      ctx.clearRect(0, 0, overlay.width, overlay.height);\r\n"
  "\r\n"
  "      ctx.save();\r\n"
  "\r\n"
  "      ctx.beginPath();\r\n"
  "      ctx.moveTo(left(configArea()), top(configArea()));\r\n"
  "      ctx.lineTo(right(configArea()), top(configArea()));\r\n"
  "      ctx.lineTo(right(configArea()), bottom(configArea()));\r\n"
  "      ctx.lineTo(left(configArea()), bottom(configArea()));\r\n"
  "      ctx.closePath();\r\n"
  "      ctx.clip();\r\n"
  "\r\n"
  "      var p = mult(inverted(combinedTransform(crosshairXAxis(), crosshairYAxis())), crosshair);\r\n"
  "      var x = crosshair[X];\r\n"
  "      var y = crosshair[Y];\r\n"
  "      if (followCurve() !== -1) {\r\n"
  "        p = findClosestPoint(isHorizontal() ? p[Y] : p[X],\r\n"
  "            seriesCurve(followCurve()), isHorizontal());\r\n"
  "        var tp = mult(combinedTransform(seriesXAxis(followCurve()),seriesYAxis(followCurve())),\r\n"
  "                      mult(curveTransform(followCurve()), p));\r\n"
  "        x = tp[X];\r\n"
  "        y = tp[Y];\r\n"
  "        crosshair[X] = x;\r\n"
  "        crosshair[Y] = y;\r\n"
  "      }\r\n"
  "      var u;\r\n"
  "      if (isHorizontal()) {\r\n"
  "        u = [(p[Y] - configArea()[1]) / configArea()[3],\r\n"
  "          (p[X] - configArea()[0]) / configArea()[2]];\r\n"
  "      } else {\r\n"
  "        u = [(p[X] - configArea()[0]) / configArea()[2],\r\n"
  "          1 - (p[Y] - configArea()[1]) / configArea()[3]];\r\n"
  "      }\r\n"
  "      if (followCurve() !== -1) {\r\n"
  "        var area = modelArea(seriesXAxis(followCurve()),seriesYAxis(followCurve()));\r\n"
  "        p = [area[0] + u[X] * area[2],\r\n"
  "             area[1] + u[Y] * area[3]];\r\n"
  "      } else {\r\n"
  "        var area = modelArea(crosshairXAxis(),crosshairYAxis());\r\n"
  "        p = [area[0] + u[X] * area[2],\r\n"
  "             area[1] + u[Y] * area[3]];\r\n"
  "      }\r\n"
  "\r\n"
  "      ctx.fillStyle = ctx.strokeStyle = config.crosshairColor;\r\n"
  "      ctx.font = '16px sans-serif';\r\n"
  "      ctx.textAlign = 'right';\r\n"
  "      ctx.textBaseline = 'top';\r\n"
  "      var textX = p[0].toFixed(2);\r\n"
  "      var textY = p[1].toFixed(2);\r\n"
  "      if (textX === '-0.00') textX = '0.00';\r\n"
  "      if (textY === '-0.00') textY = '0.00';\r\n"
  "      ctx.fillText(\"(\"+textX+\",\"+textY+\")\", right(configArea()) - coordinateOverlayPadding()[0],\r\n"
  "          top(configArea()) + coordinateOverlayPadding()[1]);\r\n"
  "\r\n"
  "      if (ctx.setLineDash) {\r\n"
  "        ctx.setLineDash([1,2]);\r\n"
  "      }\r\n"
  "      ctx.beginPath();\r\n"
  "      ctx.moveTo(Math.floor(x) + 0.5, Math.floor(top(configArea())) + 0.5);\r\n"
  "      ctx.lineTo(Math.floor(x) + 0.5, Math.floor(bottom(configArea())) + 0.5);\r\n"
  "      ctx.moveTo(Math.floor(left(configArea())) + 0.5, Math.floor(y) + 0.5);\r\n"
  "      ctx.lineTo(Math.floor(right(configArea())) + 0.5, Math.floor(y) + 0.5);\r\n"
  "      ctx.stroke();\r\n"
  "\r\n"
  "      ctx.restore();\r\n"
  "    }\r\n"
  "\r\n"
  "    // Check if the given area is within the bounds of the chart's area + some slack.\r\n"
  "    function isWithinBounds(area) {\r\n"
  "      return top(area) <= top(insideArea()) + BOUNDS_SLACK &&\r\n"
  "        bottom(area) >= bottom(insideArea()) - BOUNDS_SLACK &&\r\n"
  "        left(area) <= left(insideArea()) + BOUNDS_SLACK &&\r\n"
  "        right(area) >= right(insideArea()) - BOUNDS_SLACK;\r\n"
  "    }\r\n"
  "\r\n"
  "    function enforceLimits(flags) {\r\n"
  "      var diff;\r\n"
  "      if (isHorizontal()) {\r\n"
  "        if (flags === X_ONLY) {\r\n"
  "          flags = Y_ONLY;\r\n"
  "        } else if (flags === Y_ONLY) {\r\n"
  "          flags = X_ONLY;\r\n"
  "        }\r\n"
  "      }\r\n"
  "      for (var i = 0; i < xAxisCount(); ++i) {\r\n"
  "        var transformedArea = transformedInsideChartArea(i,0);\r\n"
  "        if (!isHorizontal()) {\r\n"
  "          if (isUndefined(flags) || flags === X_ONLY) {\r\n"
  "            if (xTransform(i)[0] < 1) {\r\n"
  "              xTransform(i)[0] = 1;\r\n"
  "              transformedArea = transformedInsideChartArea(i,0);\r\n"
  "            }\r\n"
  "            if (left(transformedArea) > left(insideArea())) {\r\n"
  "              diff = left(insideArea()) - left(transformedArea);\r\n"
  "              xTransform(i)[4] = xTransform(i)[4] + diff;\r\n"
  "            } else if (right(transformedArea) < right(insideArea())) {\r\n"
  "              diff = right(insideArea()) - right(transformedArea);\r\n"
  "              xTransform(i)[4] = xTransform(i)[4] + diff;\r\n"
  "            }\r\n"
  "          }\r\n"
  "        } else {\r\n"
  "          if (isUndefined(flags) || flags === Y_ONLY) {\r\n"
  "            if (xTransform(i)[0] < 1) {\r\n"
  "              xTransform(i)[0] = 1;\r\n"
  "              transformedArea = transformedInsideChartArea(i,0);\r\n"
  "            }\r\n"
  "            if (top(transformedArea) > top(insideArea())) {\r\n"
  "              diff = top(insideArea()) - top(transformedArea);\r\n"
  "              xTransform(i)[4] = xTransform(i)[4] + diff;\r\n"
  "            } else if (bottom(transformedArea) < bottom(insideArea())) {\r\n"
  "              diff = bottom(insideArea()) - bottom(transformedArea);\r\n"
  "              xTransform(i)[4] = xTransform(i)[4] + diff;\r\n"
  "            }\r\n"
  "          }\r\n"
  "        }\r\n"
  "      }\r\n"
  "      for (var i = 0; i < yAxisCount(); ++i) {\r\n"
  "        var transformedArea = transformedInsideChartArea(0,i);\r\n"
  "        if (!isHorizontal()) {\r\n"
  "          if (isUndefined(flags) || flags === Y_ONLY) {\r\n"
  "            if (yTransform(i)[3] < 1) {\r\n"
  "              yTransform(i)[3] = 1;\r\n"
  "              transformedArea = transformedInsideChartArea(0,i);\r\n"
  "            }\r\n"
  "            if (top(transformedArea) > top(insideArea())) {\r\n"
  "              diff = top(insideArea()) - top(transformedArea);\r\n"
  "              yTransform(i)[5] = yTransform(i)[5] - diff;\r\n"
  "            } else if (bottom(transformedArea) < bottom(insideArea())) {\r\n"
  "              diff = bottom(insideArea()) - bottom(transformedArea);\r\n"
  "              yTransform(i)[5] = yTransform(i)[5] - diff;\r\n"
  "            }\r\n"
  "          }\r\n"
  "        } else {\r\n"
  "          if (isUndefined(flags) || flags === X_ONLY) {\r\n"
  "            if (yTransform(i)[3] < 1) {\r\n"
  "              yTransform(i)[3] = 1;\r\n"
  "              transformedArea = transformedInsideChartArea(0,i);\r\n"
  "            }\r\n"
  "            if (left(transformedArea) > left(insideArea())) {\r\n"
  "              diff = left(insideArea()) - left(transformedArea);\r\n"
  "              yTransform(i)[5] = yTransform(i)[5] + diff;\r\n"
  "            } else if (right(transformedArea) < right(insideArea())) {\r\n"
  "              diff = right(insideArea()) - right(transformedArea);\r\n"
  "              yTransform(i)[5] = yTransform(i)[5] + diff;\r\n"
  "            }\r\n"
  "          }\r\n"
  "        }\r\n"
  "      }\r\n"
  "      setTransformChangedTimeout();\r\n"
  "    }\r\n"
  "\r\n"
  "    function loadTooltip() {\r\n"
  "      if (tobj.toolTipEl)\r\n"
  "        return;\r\n"
  "      APP.emit(target.widget, \"loadTooltip\", tobj.tooltipPosition[X], tobj.tooltipPosition[Y]);\r\n"
  "    }\r\n"
  "\r\n"
  "    /* const */ var MouseDistance = 10;\r\n"
  "\r\n"
  "    this.updateTooltip = function(contents) {\r\n"
  "      hideTooltip();\r\n"
  "      if (contents) {\r\n"
  "        if (!tobj.tooltipPosition) {\r\n"
  "          return;\r\n"
  "        }\r\n"
  "        tobj.toolTipEl = document.createElement('div');\r\n"
  "        tobj.toolTipEl.className = config.ToolTipInnerStyle;\r\n"
  "        tobj.toolTipEl.innerHTML = contents;\r\n"
  "\r\n"
  "        tobj.tooltipOuterDiv = document.createElement('div');\r\n"
  "        tobj.tooltipOuterDiv.className = config.ToolTipOuterStyle;\r\n"
  "\r\n"
  "        document.body.appendChild(tobj.tooltipOuterDiv);\r\n"
  "        tobj.tooltipOuterDiv.appendChild(tobj.toolTipEl);\r\n"
  "        var c = WT.widgetPageCoordinates(target.canvas);\r\n"
  "\r\n"
  "        var x = tobj.tooltipPosition[X] + c.x;\r\n"
  "        var y = tobj.tooltipPosition[Y] + c.y;\r\n"
  "        WT.fitToWindow(tobj.tooltipOuterDiv, x + MouseDistance, y + MouseDistance,\r\n"
  "            x - MouseDistance, y - MouseDistance);\r\n"
  "\r\n"
  "        $(tobj.toolTipEl).mouseenter(function() {\r\n"
  "          tobj.overTooltip = true;\r\n"
  "        });\r\n"
  "        $(tobj.toolTipEl).mouseleave(function() {\r\n"
  "          tobj.overTooltip = false;\r\n"
  "        });\r\n"
  "      }\r\n"
  "    }\r\n"
  "\r\n"
  "    this.mouseMove = function(o, event) {\r\n"
  "      // Delay mouse move, because IE reacts to\r\n"
  "      // mousemove first, but we actually want to\r\n"
  "      // handle it after pointer events.\r\n"
  "      setTimeout(function() {\r\n"
  "        setTimeout(hideTooltip, TOOLTIP_HIDE_DELAY);\r\n"
  "        if (pointerActive) return;\r\n"
  "        var c = WT.widgetCoordinates(target.canvas, event);\r\n"
  "        if (!isPointInRect(c, configArea())) return;\r\n"
  "\r\n"
  "        if (hasToolTips()) {\r\n"
  "          tobj.tooltipPosition = [c.x,c.y];\r\n"
  "          tobj.tooltipTimeout = setTimeout(function() {\r\n"
  "            loadTooltip();\r\n"
  "          }, TOOLTIP_TIMEOUT);\r\n"
  "        }\r\n"
  "\r\n"
  "        if (dragPreviousXY === null && showCrosshair() && paintEnabled) {\r\n"
  "          crosshair = [c.x,c.y];\r\n"
  "          rqAnimFrameThrottled(repaintOverlay);\r\n"
  "        }\r\n"
  "      }, 0);\r\n"
  "    }\r\n"
  "\r\n"
  "    this.mouseOut = function(o, event) {\r\n"
  "      setTimeout(hideTooltip, TOOLTIP_HIDE_DELAY);\r\n"
  "    }\r\n"
  "\r\n"
  "    this.mouseDown = function(o, event) {\r\n"
  "      if (pointerActive)\r\n"
  "        return;\r\n"
  "      var c = WT.widgetCoordinates(target.canvas, event);\r\n"
  "      var matchedYAxis = matchYAxis(c.x, c.y);\r\n"
  "      var inRect = isPointInRect(c, configArea());\r\n"
  "      var matchedXAxis = matchXAxis(c.x, c.y);\r\n"
  "      if (matchedYAxis === -1 && matchedXAxis === -1 && !inRect)\r\n"
  "        return;\r\n"
  "\r\n"
  "      dragPreviousXY = c;\r\n"
  "      dragCurrentXAxis = matchedXAxis;\r\n"
  "      dragCurrentYAxis = matchedYAxis;\r\n"
  "    };\r\n"
  "\r\n"
  "    this.mouseUp = function(o, event) {\r\n"
  "      if (pointerActive)\r\n"
  "        return;\r\n"
  "      dragPreviousXY = null;\r\n"
  "      dragCurrentXAxis = -1;\r\n"
  "      dragCurrentYAxis = -1;\r\n"
  "    };\r\n"
  "\r\n"
  "    this.mouseDrag = function(o, event) {\r\n"
  "      if (pointerActive)\r\n"
  "        return;\r\n"
  "      if (dragPreviousXY === null) {\r\n"
  "        self.mouseDown(o, event);\r\n"
  "        return;\r\n"
  "      }\r\n"
  "      var c = WT.widgetCoordinates(target.canvas, event);\r\n"
  "      if (WT.buttons === 1) {\r\n"
  "        if (dragCurrentYAxis === -1 && dragCurrentXAxis === -1 &&\r\n"
  "            curveManipulation() && configSeries(configSelectedCurve())) {\r\n"
  "          var curve = configSelectedCurve();\r\n"
  "          var dy;\r\n"
  "          if (isHorizontal()) {\r\n"
  "            dy = c.x - dragPreviousXY.x;\r\n"
  "          } else {\r\n"
  "            dy = c.y - dragPreviousXY.y;\r\n"
  "          }\r\n"
  "          assign(seriesTransform(curve),\r\n"
  "              mult([1,0,0,1,0,dy / yTransform(seriesYAxis(configSelectedCurve()))[3]],\r\n"
  "                seriesTransform(curve)));\r\n"
  "          repaint();\r\n"
  "        } else if (config.pan) {\r\n"
  "          translate({\r\n"
  "            x: c.x - dragPreviousXY.x,\r\n"
  "            y: c.y - dragPreviousXY.y\r\n"
  "          }, 0, dragCurrentXAxis, dragCurrentYAxis);\r\n"
  "        }\r\n"
  "      }\r\n"
  "      dragPreviousXY = c;\r\n"
  "    };\r\n"
  "\r\n"
  "    this.clicked = function(o, event) {\r\n"
  "      if (pointerActive) return;\r\n"
  "      if (dragPreviousXY !== null) return;\r\n"
  "      if (!seriesSelection()) return;\r\n"
  "      var c = WT.widgetCoordinates(target.canvas, event);\r\n"
  "      APP.emit(target.widget, 'seriesSelected', c.x, c.y);\r\n"
  "    };\r\n"
  "\r\n"
  "    function init() {\r\n"
  "      if (showCrosshair() && (isUndefined(overlay) || target.canvas.width !== overlay.width || target.canvas.height !== overlay.height)) {\r\n"
  "        if (overlay) {\r\n"
  "          overlay.parentNode.removeChild(overlay);\r\n"
  "          delete widget.wtOObj;\r\n"
  "          overlay = undefined;\r\n"
  "        }\r\n"
  "        var c = document.createElement(\"canvas\");\r\n"
  "        c.setAttribute(\"width\", target.canvas.width);\r\n"
  "        c.setAttribute(\"height\", target.canvas.height);\r\n"
  "        c.style.position = 'absolute';\r\n"
  "        c.style.display = 'block';\r\n"
  "        c.style.left = '0';\r\n"
  "        c.style.top = '0';\r\n"
  "        if (window.MSPointerEvent || window.PointerEvent) {\r\n"
  "          c.style.msTouchAction = 'none';\r\n"
  "          c.style.touchAction = 'none';\r\n"
  "        }\r\n"
  "        target.canvas.parentNode.appendChild(c);\r\n"
  "        overlay = c;\r\n"
  "        widget.wtOObj = overlay;\r\n"
  "      } else if (!isUndefined(overlay) && !showCrosshair()) {\r\n"
  "        // If the mouse handler is not reinitialized, we don't actually get here!\r\n"
  "        overlay.parentNode.removeChild(overlay);\r\n"
  "        delete widget.wtOObj;\r\n"
  "        overlay = undefined;\r\n"
  "      }\r\n"
  "\r\n"
  "      crosshair = [(left(configArea()) + right(configArea())) / 2,\r\n"
  "      (top(configArea()) + bottom(configArea())) / 2];\r\n"
  "    }\r\n"
  "\r\n"
  "    this.mouseWheel = function(o, event) {\r\n"
  "      var modifiers = (event.metaKey << 3) + (event.altKey << 2) + (event.ctrlKey << 1) + event.shiftKey;\r\n"
  "      var action = config.wheelActions[modifiers];\r\n"
  "      if (isUndefined(action)) return;\r\n"
  "\r\n"
  "      var c = WT.widgetCoordinates(target.canvas, event);\r\n"
  "      var matchedXAxis = matchXAxis(c.x, c.y);\r\n"
  "      var matchedYAxis = matchYAxis(c.x, c.y);\r\n"
  "      var inRect = isPointInRect(c, configArea());\r\n"
  "      if (matchedXAxis === -1 && matchedYAxis === -1 && !inRect)\r\n"
  "        return;\r\n"
  "      var w = WT.normalizeWheel(event);\r\n"
  "      if (inRect && modifiers === 0 && curveManipulation()) {\r\n"
  "        // Scale the curve around its middle\r\n"
  "        var curve = configSelectedCurve();\r\n"
  "        var d = -w.spinY;\r\n"
  "        if (configSeries(curve)) {\r\n"
  "          var t = curveTransform(curve);\r\n"
  "          var s = apply(t,seriesCurve(curve));\r\n"
  "          var minMax = minMaxY(s, isHorizontal());\r\n"
  "          var middle = (minMax[0] + minMax[1]) / 2;\r\n"
  "          WT.cancelEvent(event);\r\n"
  "          var s_y = Math.pow(1.2, d);\r\n"
  "          assign(seriesTransform(curve),\r\n"
  "              mult([1,0,0,s_y,0,middle-s_y*middle],\r\n"
  "                seriesTransform(curve)));\r\n"
  "          repaint();\r\n"
  "          return;\r\n"
  "        }\r\n"
  "      }\r\n"
  "      if ((action === WHEEL_PAN_X || action === WHEEL_PAN_Y || action === WHEEL_PAN_MATCHING) && config.pan) {\r\n"
  "        var xBefore = [];\r\n"
  "        for (var xAx = 0; xAx < xAxisCount(); ++xAx) {\r\n"
  "          xBefore.push(xTransform(xAx)[4]);\r\n"
  "        }\r\n"
  "        var yBefore = [];\r\n"
  "        for (var yAx = 0; yAx < yAxisCount(); ++yAx) {\r\n"
  "          yBefore.push(yTransform(yAx)[5]);\r\n"
  "        }\r\n"
  "        if (action === WHEEL_PAN_MATCHING)\r\n"
  "          translate({x:-w.pixelX,y:-w.pixelY}, 0, matchedXAxis, matchedYAxis);\r\n"
  "        else if (action === WHEEL_PAN_Y)\r\n"
  "          translate({x:0,y:-w.pixelX - w.pixelY}, 0, matchedXAxis, matchedYAxis);\r\n"
  "        else if (action === WHEEL_PAN_X)\r\n"
  "          translate({x:-w.pixelX - w.pixelY,y:0}, 0, matchedXAxis, matchedYAxis);\r\n"
  "        for (var xAx = 0; xAx < xAxisCount(); ++xAx) {\r\n"
  "          if (xBefore[xAx] !== xTransform(xAx)[4])\r\n"
  "            WT.cancelEvent(event);\r\n"
  "        }\r\n"
  "        for (var yAx = 0; yAx < yAxisCount(); ++yAx) {\r\n"
  "          if (yBefore[yAx] !== yTransform(yAx)[5])\r\n"
  "            WT.cancelEvent(event);\r\n"
  "        }\r\n"
  "      } else if (config.zoom) {\r\n"
  "        WT.cancelEvent(event);\r\n"
  "        var d = -w.spinY;\r\n"
  "        // Some browsers scroll horizontally when shift key pressed\r\n"
  "        if (d === 0) d = -w.spinX;\r\n"
  "        if (action === WHEEL_ZOOM_Y) {\r\n"
  "          zoom(c, 0, d, matchedXAxis, matchedYAxis);\r\n"
  "        } else if (action === WHEEL_ZOOM_X) {\r\n"
  "          zoom(c, d, 0, matchedXAxis, matchedYAxis);\r\n"
  "        } else if (action === WHEEL_ZOOM_XY) {\r\n"
  "          zoom(c, d, d, matchedXAxis, matchedYAxis);\r\n"
  "        } else if (action === WHEEL_ZOOM_MATCHING) {\r\n"
  "          if (w.pixelX !== 0)\r\n"
  "            zoom(c, d, 0, matchedXAxis, matchedYAxis);\r\n"
  "          else\r\n"
  "            zoom(c, 0, d, matchedXAxis, matchedYAxis);\r\n"
  "        }\r\n"
  "      }\r\n"
  "    };\r\n"
  "\r\n"
  "    var CROSSHAIR_RADIUS = 30;\r\n"
  "\r\n"
  "    var seriesSelected = function() {\r\n"
  "      if (!seriesSelection())\r\n"
  "        return;\r\n"
  "      APP.emit(target.widget, 'seriesSelected', dragPreviousXY.x, dragPreviousXY.y);\r\n"
  "    }\r\n"
  "\r\n"
  "    function topElement() {\r\n"
  "      if (overlay)\r\n"
  "        return overlay;\r\n"
  "      else\r\n"
  "        return target.canvas;\r\n"
  "    }\r\n"
  "\r\n"
  "    // fromDoubleTouch: indicates that this start of a touch comes from releasing of a double touch,\r\n"
  "    //                  so should not be interpreted for series selection\r\n"
  "    touchHandlers.start = function(o, event, fromDoubleTouch) {\r\n"
  "      singleTouch = len(event.touches) === 1;\r\n"
  "      doubleTouch = len(event.touches) === 2;\r\n"
  "\r\n"
  "      if (singleTouch) {\r\n"
  "        animating = false;\r\n"
  "        var c = WT.widgetCoordinates(target.canvas, event.touches[0]);\r\n"
  "        var matchedYAxis = matchYAxis(c.x, c.y);\r\n"
  "        var inRect = isPointInRect(c, configArea());\r\n"
  "        var matchedXAxis = matchXAxis(c.x, c.y);\r\n"
  "        if (matchedYAxis === -1 && matchedXAxis === -1 && !inRect)\r\n"
  "          return;\r\n"
  "        if (matchedYAxis === -1 && matchedXAxis === -1 && showCrosshair() && distanceLessThanRadius(crosshair, [c.x,c.y], CROSSHAIR_RADIUS)) {\r\n"
  "          mode = CROSSHAIR_MODE;\r\n"
  "        } else {\r\n"
  "          mode = LOOK_MODE;\r\n"
  "        }\r\n"
  "        lastDate = Date.now();\r\n"
  "        dragPreviousXY = c;\r\n"
  "        dragCurrentYAxis = matchedYAxis;\r\n"
  "        dragCurrentXAxis = matchedXAxis;\r\n"
  "        if (mode !== CROSSHAIR_MODE) {\r\n"
  "          if (!fromDoubleTouch && inRect) {\r\n"
  "            seriesSelectionTimeout = window.setTimeout(seriesSelected, SERIES_SELECTION_TIMEOUT);\r\n"
  "          }\r\n"
  "          addEventListener('contextmenu', eobj2.contextmenuListener);\r\n"
  "        }\r\n"
  "        WT.capture(null);\r\n"
  "        WT.capture(topElement());\r\n"
  "      } else if (doubleTouch && (config.zoom || curveManipulation())) {\r\n"
  "        if (seriesSelectionTimeout) {\r\n"
  "          window.clearTimeout(seriesSelectionTimeout);\r\n"
  "          seriesSelectionTimeout = null;\r\n"
  "        }\r\n"
  "        animating = false;\r\n"
  "        touches = [\r\n"
  "          WT.widgetCoordinates(target.canvas,event.touches[0]),\r\n"
  "          WT.widgetCoordinates(target.canvas,event.touches[1])\r\n"
  "        ].map(function(t){return [t.x,t.y];});\r\n"
  "        var matchedXAxis = -1;\r\n"
  "        var matchedYAxis = -1;\r\n"
  "        if (!touches.every(function(p){return isPointInRect(p,configArea());})) {\r\n"
  "          matchedXAxis = matchXAxis(touches[0][X], touches[0][Y]);\r\n"
  "          if (matchedXAxis !== -1) {\r\n"
  "            if (matchedXAxis !== matchXAxis(touches[1][X], touches[1][Y])) {\r\n"
  "              doubleTouch = null;\r\n"
  "              return;\r\n"
  "            }\r\n"
  "          } else {\r\n"
  "            matchedYAxis = matchYAxis(touches[0][X], touches[0][Y]);\r\n"
  "            if (matchedYAxis !== 1) {\r\n"
  "              if (matchedYAxis !== matchYAxis(touches[1][X], touches[1][Y])) {\r\n"
  "                doubleTouch = null;\r\n"
  "                return;\r\n"
  "              }\r\n"
  "            } else {\r\n"
  "              doubleTouch = null;\r\n"
  "              return;\r\n"
  "            }\r\n"
  "          }\r\n"
  "        }\r\n"
  "        WT.capture(null);\r\n"
  "        WT.capture(topElement());\r\n"
  "        zoomAngle = Math.atan2(touches[1][1] - touches[0][1], touches[1][0] - touches[0][0]);\r\n"
  "        zoomMiddle = [\r\n"
  "          (touches[0][0] + touches[1][0]) / 2,\r\n"
  "          (touches[0][1] + touches[1][1]) / 2];\r\n"
  "        var sin = Math.abs(Math.sin(zoomAngle));\r\n"
  "        var cos = Math.abs(Math.cos(zoomAngle));\r\n"
  "        if (sin < Math.sin(22.5 / 180 * Math.PI)) {\r\n"
  "          zoomAngle = 0;\r\n"
  "        } else if (cos < Math.cos(67.5 / 180 * Math.PI)) {\r\n"
  "          zoomAngle = Math.PI / 2;\r\n"
  "        } else if (Math.tan(zoomAngle) > 0) {\r\n"
  "          zoomAngle = Math.PI / 4;\r\n"
  "        } else {\r\n"
  "          zoomAngle = -Math.PI / 4;\r\n"
  "        }\r\n"
  "        zoomProjection = projection(zoomAngle, zoomMiddle);\r\n"
  "        dragCurrentXAxis = matchedXAxis;\r\n"
  "        dragCurrentYAxis = matchedYAxis;\r\n"
  "      } else {\r\n"
  "        return;\r\n"
  "      }\r\n"
  "      preventDefault(event);\r\n"
  "    };\r\n"
  "\r\n"
  "    function animate(ts, dt) {\r\n"
  "      if (!animating)\r\n"
  "        return;\r\n"
  "      var now = Date.now();\r\n"
  "      if (isUndefined(dt)) {\r\n"
  "        dt = now - lastDate;\r\n"
  "      }\r\n"
  "      var d = {x: 0, y: 0};\r\n"
  "      var area;\r\n"
  "      if (dragCurrentXAxis !== -1) {\r\n"
  "        area = transformedInsideChartArea(dragCurrentXAxis,0);\r\n"
  "      } else if (dragCurrentYAxis === -1) {\r\n"
  "        area = transformedInsideChartArea(0, 0);\r\n"
  "        for (var xAx = 1; xAx < xAxisCount(); ++xAx) {\r\n"
  "          area = intersection(area, transformedInsideChartArea(xAx, 0));\r\n"
  "        }\r\n"
  "        for (var yAx = 1; yAx < yAxisCount(); ++yAx) {\r\n"
  "          area = intersection(area, transformedInsideChartArea(0, yAx));\r\n"
  "        }\r\n"
  "      } else {\r\n"
  "        area = transformedInsideChartArea(0,dragCurrentYAxis);\r\n"
  "      }\r\n"
  "      var k = SPRING_CONSTANT;\r\n"
  "\r\n"
  "      if (dt > 2 * ANIMATION_INTERVAL) {\r\n"
  "        paintEnabled = false;\r\n"
  "        var i = Math.floor(dt / ANIMATION_INTERVAL - 1);\r\n"
  "        var j;\r\n"
  "        for (j = 0; j < i; ++j) {\r\n"
  "          animate(ts, ANIMATION_INTERVAL);\r\n"
  "          if (!animating) {\r\n"
  "            paintEnabled = true;\r\n"
  "            repaint();\r\n"
  "            return;\r\n"
  "          }\r\n"
  "        }\r\n"
  "        dt -= i * ANIMATION_INTERVAL;\r\n"
  "        paintEnabled = true;\r\n"
  "      }\r\n"
  "\r\n"
  "      // Calculate new area position and v.x, v.y\r\n"
  "      if (v.x === Infinity || v.x === -Infinity) {\r\n"
  "        if (v.x > 0) v.x = MAX_SPEED;\r\n"
  "        else v.x = -MAX_SPEED;\r\n"
  "      }\r\n"
  "      if (isFinite(v.x)) {\r\n"
  "        v.x = v.x / (1 + FRICTION_FACTOR * dt);\r\n"
  "        area[0] += v.x * dt;\r\n"
  "        if (left(area) > left(insideArea())) {\r\n"
  "          v.x = v.x + (-k) * (left(area) - left(insideArea())) * dt;\r\n"
  "          v.x *= 0.7;\r\n"
  "        } else if (right(area) < right(insideArea())) {\r\n"
  "          v.x = v.x + (-k) * (right(area) - right(insideArea())) * dt;\r\n"
  "          v.x *= 0.7;\r\n"
  "        }\r\n"
  "        if (Math.abs(v.x) < MIN_SPEED) {\r\n"
  "          if (left(area) > left(insideArea())) {\r\n"
  "            v.x = MIN_SPEED;\r\n"
  "          } else if (right(area) < right(insideArea())) {\r\n"
  "            v.x = -MIN_SPEED;\r\n"
  "          }\r\n"
  "        }\r\n"
  "        // cap speed\r\n"
  "        if (Math.abs(v.x) > MAX_SPEED) v.x = (v.x > 0 ? 1 : -1) * MAX_SPEED;\r\n"
  "        d.x = v.x * dt;\r\n"
  "      }\r\n"
  "      if (v.y === Infinity || v.y === -Infinity) {\r\n"
  "        if (v.y > 0) v.y = MAX_SPEED;\r\n"
  "        else v.y = -MAX_SPEED;\r\n"
  "      }\r\n"
  "      if (isFinite(v.y)) {\r\n"
  "        v.y = v.y / (1 + FRICTION_FACTOR * dt);\r\n"
  "        area[1] += v.y * dt;\r\n"
  "        if (top(area) > top(insideArea())) {\r\n"
  "          v.y = v.y + (-k) * (top(area) - top(insideArea())) * dt;\r\n"
  "          v.y *= 0.7;\r\n"
  "        } else if (bottom(area) < bottom(insideArea())) {\r\n"
  "          v.y = v.y + (-k) * (bottom(area) - bottom(insideArea())) * dt;\r\n"
  "          v.y *= 0.7;\r\n"
  "        }\r\n"
  "        if (Math.abs(v.y) < 0.001) {\r\n"
  "          if (top(area) > top(insideArea())) {\r\n"
  "            v.y = 0.001;\r\n"
  "          } else if (bottom(area) < bottom(insideArea())) {\r\n"
  "            v.y = -0.001;\r\n"
  "          }\r\n"
  "        }\r\n"
  "        // cap speed\r\n"
  "        if (Math.abs(v.y) > MAX_SPEED) v.y = (v.y > 0 ? 1 : -1) * MAX_SPEED;\r\n"
  "        d.y = v.y * dt;\r\n"
  "      }\r\n"
  "\r\n"
  "      if (dragCurrentXAxis !== -1) {\r\n"
  "        area = transformedInsideChartArea(dragCurrentXAxis, 0);\r\n"
  "      } else if (dragCurrentYAxis === -1) {\r\n"
  "        area = transformedInsideChartArea(0, 0);\r\n"
  "        for (var xAx = 1; xAx < xAxisCount(); ++xAx) {\r\n"
  "          area = intersection(area, transformedInsideChartArea(xAx, 0));\r\n"
  "        }\r\n"
  "        for (var yAx = 1; yAx < yAxisCount(); ++yAx) {\r\n"
  "          area = intersection(area, transformedInsideChartArea(0, yAx));\r\n"
  "        }\r\n"
  "      } else {\r\n"
  "        area = transformedInsideChartArea(0, dragCurrentYAxis);\r\n"
  "      }\r\n"
  "      translate(d, NO_LIMIT, dragCurrentXAxis, dragCurrentYAxis);\r\n"
  "      var newArea;\r\n"
  "      if (dragCurrentXAxis !== -1) {\r\n"
  "        newArea = transformedInsideChartArea(dragCurrentXAxis, 0);\r\n"
  "      } else if (dragCurrentYAxis === -1) {\r\n"
  "        newArea = transformedInsideChartArea(0, 0);\r\n"
  "        for (var xAx = 1; xAx < xAxisCount(); ++xAx) {\r\n"
  "          newArea = intersection(newArea, transformedInsideChartArea(xAx, 0));\r\n"
  "        }\r\n"
  "        for (var yAx = 1; yAx < yAxisCount(); ++yAx) {\r\n"
  "          newArea = intersection(newArea, transformedInsideChartArea(0, yAx));\r\n"
  "        }\r\n"
  "      } else {\r\n"
  "        newArea = transformedInsideChartArea(0, dragCurrentYAxis);\r\n"
  "      }\r\n"
  "      if (left(area) > left(insideArea()) &&\r\n"
  "          left(newArea) <= left(insideArea())) {\r\n"
  "        v.x = 0;\r\n"
  "        translate({x:-d.x,y:0}, NO_LIMIT, dragCurrentXAxis, dragCurrentYAxis);\r\n"
  "        enforceLimits(X_ONLY);\r\n"
  "      }\r\n"
  "      if (right(area) < right(insideArea()) &&\r\n"
  "          right(newArea) >= right(insideArea())) {\r\n"
  "        v.x = 0;\r\n"
  "        translate({x:-d.x,y:0}, NO_LIMIT, dragCurrentXAxis, dragCurrentYAxis);\r\n"
  "        enforceLimits(X_ONLY);\r\n"
  "      }\r\n"
  "      if (top(area) > top(insideArea()) &&\r\n"
  "          top(newArea) <= top(insideArea())) {\r\n"
  "        v.y = 0;\r\n"
  "        translate({x:0,y:-d.y}, NO_LIMIT, dragCurrentXAxis, dragCurrentYAxis);\r\n"
  "        enforceLimits(Y_ONLY);\r\n"
  "      }\r\n"
  "      if (bottom(area) < bottom(insideArea()) &&\r\n"
  "          bottom(newArea) >= bottom(insideArea())) {\r\n"
  "        v.y = 0;\r\n"
  "        translate({x:0,y:-d.y}, NO_LIMIT, dragCurrentXAxis, dragCurrentYAxis);\r\n"
  "        enforceLimits(Y_ONLY);\r\n"
  "      }\r\n"
  "      if (Math.abs(v.x) < STOPPING_SPEED &&\r\n"
  "          Math.abs(v.y) < STOPPING_SPEED &&\r\n"
  "          isWithinBounds(newArea)) {\r\n"
  "        enforceLimits();\r\n"
  "        animating = false;\r\n"
  "        dragPreviousXY = null;\r\n"
  "        v.x = 0;\r\n"
  "        // Calculate new area p\r\n"
  "        v.y = 0;\r\n"
  "        lastDate = null;\r\n"
  "        touches = [];\r\n"
  "      } else {\r\n"
  "        lastDate = now;\r\n"
  "        if (paintEnabled) {\r\n"
  "          rqAnimFrame(animate);\r\n"
  "        }\r\n"
  "      }\r\n"
  "    }\r\n"
  "\r\n"
  "    touchHandlers.end = function(o, event) {\r\n"
  "      if (seriesSelectionTimeout) {\r\n"
  "        window.clearTimeout(seriesSelectionTimeout);\r\n"
  "        seriesSelectionTimeout = null;\r\n"
  "      }\r\n"
  "      window.setTimeout(function() {\r\n"
  "        removeEventListener('contextmenu', eobj2.contextmenuListener);\r\n"
  "      }, 0);\r\n"
  "      var touches = Array.prototype.slice.call(event.touches);\r\n"
  "\r\n"
  "      var noTouch = len(touches) === 0;\r\n"
  "\r\n"
  "      if (!noTouch) {\r\n"
  "        (function(){\r\n"
  "          var i;\r\n"
  "          for (i = 0; i < len(event.changedTouches); ++i) {\r\n"
  "            (function(){\r\n"
  "              var id = event.changedTouches[i].identifier;\r\n"
  "              for (var j = 0; j < len(touches); ++j) {\r\n"
  "                if (touches[j].identifier === id) {\r\n"
  "                  touches.splice(j, 1);\r\n"
  "                  return;\r\n"
  "                }\r\n"
  "              }\r\n"
  "            })();\r\n"
  "          }\r\n"
  "        })();\r\n"
  "      }\r\n"
  "\r\n"
  "      noTouch     = len(touches) === 0;\r\n"
  "      singleTouch = len(touches) === 1;\r\n"
  "      doubleTouch = len(touches) === 2;\r\n"
  "\r\n"
  "      if (noTouch) {\r\n"
  "        moveTimeout = null;\r\n"
  "        if (mode === LOOK_MODE && (isFinite(v.x) || isFinite(v.y)) && config.rubberBand) {\r\n"
  "          lastDate = Date.now();\r\n"
  "          animating = true;\r\n"
  "          rqAnimFrame(animate);\r\n"
  "        } else {\r\n"
  "          if (mode === CROSSHAIR_MODE)\r\n"
  "            self.mouseUp(null, null);\r\n"
  "          touches = [];\r\n"
  "          zoomAngle = null;\r\n"
  "          zoomMiddle = null;\r\n"
  "          zoomProjection = null;\r\n"
  "          lastDate = null;\r\n"
  "        }\r\n"
  "        mode = null;\r\n"
  "      } else if (singleTouch || doubleTouch)\r\n"
  "        touchHandlers.start(o, event, true);\r\n"
  "    };\r\n"
  "\r\n"
  "    var moveTimeout = null;\r\n"
  "    var c1 = null;\r\n"
  "    var c2 = null;\r\n"
  "\r\n"
  "    touchHandlers.moved = function(o, event) {\r\n"
  "      if ( (!singleTouch) && (!doubleTouch) ) {\r\n"
  "        return;\r\n"
  "      }\r\n"
  "      if (singleTouch && dragPreviousXY == null) return;\r\n"
  "      preventDefault(event);\r\n"
  "      c1 = WT.widgetCoordinates(target.canvas, event.touches[0]);\r\n"
  "      // kind of breaks pinch-to-zoom?\r\n"
  "      if (len(event.touches) > 1)\r\n"
  "        c2 = WT.widgetCoordinates(target.canvas, event.touches[1]);\r\n"
  "      if (dragCurrentXAxis === -1 && dragCurrentYAxis === -1 && singleTouch && seriesSelectionTimeout && !distanceLessThanRadius([c1.x,c1.y],[dragPreviousXY.x,dragPreviousXY.y],3)) {\r\n"
  "        window.clearTimeout(seriesSelectionTimeout);\r\n"
  "        seriesSelectionTimeout = null;\r\n"
  "      }\r\n"
  "      // setTimeout prevents high animation velocity due to looking\r\n"
  "      // at events that are further apart.\r\n"
  "      if (!moveTimeout) moveTimeout = setTimeout(function(){\r\n"
  "        if (dragCurrentXAxis === -1 && dragCurrentYAxis === -1 && singleTouch && curveManipulation() && configSeries(configSelectedCurve())) {\r\n"
  "          var curve = configSelectedCurve();\r\n"
  "          if (configSeries(curve)) {\r\n"
  "            var c = c1;\r\n"
  "            var dy;\r\n"
  "            if (isHorizontal()) {\r\n"
  "              dy = (c.x - dragPreviousXY.x) / yTransform(seriesYAxis(configSelectedCurve()))[3];\r\n"
  "            } else {\r\n"
  "              dy = (c.y - dragPreviousXY.y) / yTransform(seriesYAxis(configSelectedCurve()))[3];\r\n"
  "            }\r\n"
  "            seriesTransform(curve)[5] += dy;\r\n"
  "            dragPreviousXY = c;\r\n"
  "            repaint();\r\n"
  "          }\r\n"
  "        } else if (singleTouch) {\r\n"
  "          var c = c1;\r\n"
  "          var now = Date.now();\r\n"
  "          var d = {\r\n"
  "            x: c.x - dragPreviousXY.x,\r\n"
  "            y: c.y - dragPreviousXY.y\r\n"
  "          };\r\n"
  "          var dt = now - lastDate;\r\n"
  "          lastDate = now;\r\n"
  "          if (mode === CROSSHAIR_MODE) {\r\n"
  "            crosshair[X] += d.x;\r\n"
  "            crosshair[Y] += d.y;\r\n"
  "            if (showCrosshair() && paintEnabled) {\r\n"
  "              rqAnimFrame(repaintOverlay);\r\n"
  "            }\r\n"
  "          } else if (config.pan) {\r\n"
  "            v.x = d.x / dt;\r\n"
  "            v.y = d.y / dt;\r\n"
  "            translate(d, config.rubberBand ? DAMPEN : 0, dragCurrentXAxis, dragCurrentYAxis);\r\n"
  "          }\r\n"
  "          dragPreviousXY = c;\r\n"
  "        } else if (dragCurrentXAxis === -1 && dragCurrentYAxis === -1 && doubleTouch && curveManipulation() && configSeries(configSelectedCurve())) {\r\n"
  "          var yAxis = isHorizontal() ? X : Y;\r\n"
  "          var newTouches = [ c1, c2 ].map(function(t){\r\n"
  "            if (isHorizontal()) {\r\n"
  "              return [t.x, myBefore];\r\n"
  "            } else {\r\n"
  "              return [mxBefore, t.y];\r\n"
  "            }\r\n"
  "          });\r\n"
  "          var dyBefore = Math.abs(touches[1][yAxis] - touches[0][yAxis]);\r\n"
  "          var dyAfter = Math.abs(newTouches[1][yAxis] - newTouches[0][yAxis]);\r\n"
  "          var yScale = dyBefore > 0 ? dyAfter / dyBefore : 1;\r\n"
  "          if (dyAfter === dyBefore) {\r\n"
  "            yScale = 1;\r\n"
  "          }\r\n"
  "          var curve = configSelectedCurve();\r\n"
  "          if (configSeries(curve)) {\r\n"
  "            var myBefore = mult(inverted(combinedTransform(seriesXAxis(curve),seriesYAxis(curve))), [0, (touches[0][yAxis] + touches[1][yAxis]) / 2])[1];\r\n"
  "            var myAfter = mult(inverted(combinedTransform(seriesXAxis(curve),seriesYAxis(curve))), [0, (newTouches[0][yAxis] + newTouches[1][yAxis]) / 2])[1];\r\n"
  "            assign(seriesTransform(curve),\r\n"
  "                mult(\r\n"
  "                  [1,0,0,yScale,0,-yScale*myBefore+myAfter],\r\n"
  "                  seriesTransform(curve)\r\n"
  "                  )\r\n"
  "                );\r\n"
  "            dragPreviousXY = c;\r\n"
  "            repaint();\r\n"
  "            touches = newTouches;\r\n"
  "          }\r\n"
  "        } else if (doubleTouch && config.zoom) {\r\n"
  "          var crosshairBefore = toModelCoord(crosshair, crosshairXAxis(), crosshairYAxis());\r\n"
  "          var mxBefore = (touches[0][0] + touches[1][0]) / 2;\r\n"
  "          var myBefore = (touches[0][1] + touches[1][1]) / 2;\r\n"
  "          var newTouches = [ c1, c2 ].map(function(t){\r\n"
  "            if (zoomAngle === 0) {\r\n"
  "              return [t.x, myBefore];\r\n"
  "            } else if (zoomAngle === Math.PI / 2) {\r\n"
  "              return [mxBefore, t.y];\r\n"
  "            } else {\r\n"
  "              return mult(zoomProjection,[t.x,t.y]);\r\n"
  "            }\r\n"
  "          });\r\n"
  "\r\n"
  "          var dxBefore = Math.abs(touches[1][0] - touches[0][0]);\r\n"
  "          var dxAfter = Math.abs(newTouches[1][0] - newTouches[0][0]);\r\n"
  "          var xScale = dxBefore > 0 ? dxAfter / dxBefore : 1;\r\n"
  "          if (dxAfter === dxBefore || zoomAngle === Math.PI / 2) {\r\n"
  "            xScale = 1;\r\n"
  "          }\r\n"
  "          var mxAfter = (newTouches[0][0] + newTouches[1][0]) / 2;\r\n"
  "          var dyBefore = Math.abs(touches[1][1] - touches[0][1]);\r\n"
  "          var dyAfter = Math.abs(newTouches[1][1] - newTouches[0][1]);\r\n"
  "          var yScale = dyBefore > 0 ? dyAfter / dyBefore : 1;\r\n"
  "          if (dyAfter === dyBefore || zoomAngle === 0) {\r\n"
  "            yScale = 1;\r\n"
  "          }\r\n"
  "          var myAfter = (newTouches[0][1] + newTouches[1][1]) / 2;\r\n"
  "\r\n"
  "          if (isHorizontal()) {\r\n"
  "            (function() {\r\n"
  "              var tmp = xScale;\r\n"
  "              xScale = yScale;\r\n"
  "              yScale = tmp;\r\n"
  "              tmp = mxAfter;\r\n"
  "              mxAfter = myAfter;\r\n"
  "              myAfter = tmp;\r\n"
  "              tmp = mxBefore;\r\n"
  "              mxBefore = myBefore;\r\n"
  "              myBefore = tmp;\r\n"
  "            })();\r\n"
  "          }\r\n"
  "\r\n"
  "          var xScalePerAxis = [];\r\n"
  "          for (var xAx = 0; xAx < xAxisCount(); ++xAx) {\r\n"
  "            xScalePerAxis.push(xScale);\r\n"
  "          }\r\n"
  "          for (var xAx = 0; xAx < xAxisCount(); ++xAx) {\r\n"
  "            if (xTransform(xAx)[0] * xScalePerAxis[xAx] > maxXZoom(xAx)) {\r\n"
  "              xScalePerAxis[xAx] = maxXZoom(xAx) / xTransform(xAx)[0];\r\n"
  "            }\r\n"
  "            if (xTransform(xAx)[0] * xScalePerAxis[xAx] < minXZoom(xAx)) {\r\n"
  "              xScalePerAxis[xAx] = minXZoom(xAx) / xTransform(xAx)[0];\r\n"
  "            }\r\n"
  "          }\r\n"
  "          var yScalePerAxis = [];\r\n"
  "          for (var yAx = 0; yAx < yAxisCount(); ++yAx) {\r\n"
  "            yScalePerAxis.push(yScale);\r\n"
  "          }\r\n"
  "          for (var yAx = 0; yAx < yAxisCount(); ++yAx) {\r\n"
  "            if (yTransform(yAx)[3] * yScalePerAxis[yAx] > maxYZoom(yAx)) {\r\n"
  "              yScalePerAxis[yAx] = maxYZoom(yAx) / yTransform(yAx)[3];\r\n"
  "            }\r\n"
  "            if (yTransform(yAx)[3] * yScalePerAxis[yAx] < minYZoom(yAx)) {\r\n"
  "              yScalePerAxis[yAx] = minYZoom(yAx) / yTransform(yAx)[3];\r\n"
  "            }\r\n"
  "          }\r\n"
  "          if (dragCurrentXAxis !== -1) {\r\n"
  "            if (xScalePerAxis[dragCurrentXAxis] !== 1 &&\r\n"
  "                (xScalePerAxis[dragCurrentXAxis] < 1.0 || xTransform(dragCurrentXAxis)[0] !== maxXZoom(dragCurrentXAxis))) {\r\n"
  "              tAssign(xTransform(dragCurrentXAxis),\r\n"
  "                  mult(\r\n"
  "                    [xScalePerAxis[dragCurrentXAxis],0,0,1,-xScalePerAxis[dragCurrentXAxis]*mxBefore+mxAfter,0],\r\n"
  "                    xTransform(dragCurrentXAxis)\r\n"
  "                    )\r\n"
  "                  );\r\n"
  "            }\r\n"
  "          } else if (dragCurrentYAxis === -1) {\r\n"
  "            for (var xAx = 0; xAx < xAxisCount(); ++xAx) {\r\n"
  "              if (xScalePerAxis[xAx] !== 1 &&\r\n"
  "                  (xScalePerAxis[xAx] < 1.0 || xTransform(xAx)[0] !== maxXZoom(xAx))) {\r\n"
  "                tAssign(xTransform(xAx),\r\n"
  "                    mult(\r\n"
  "                      [xScalePerAxis[xAx],0,0,1,-xScalePerAxis[xAx]*mxBefore+mxAfter,0],\r\n"
  "                      xTransform(xAx)\r\n"
  "                    )\r\n"
  "                );\r\n"
  "              }\r\n"
  "            }\r\n"
  "            for (var yAx = 0; yAx < yAxisCount(); ++yAx) {\r\n"
  "              if (yScalePerAxis[yAx] !== 1 &&\r\n"
  "                  (yScalePerAxis[yAx] < 1.0 || yTransform(yAx)[3] !== maxYZoom(yAx))) {\r\n"
  "                tAssign(yTransform(yAx),\r\n"
  "                    mult(\r\n"
  "                      [1,0,0,yScalePerAxis[yAx],0,-yScalePerAxis[yAx]*myBefore+myAfter],\r\n"
  "                      yTransform(yAx)\r\n"
  "                      )\r\n"
  "                    );\r\n"
  "              }\r\n"
  "            }\r\n"
  "          } else {\r\n"
  "            if (yScalePerAxis[dragCurrentYAxis] !== 1 &&\r\n"
  "                (yScalePerAxis[dragCurrentYAxis] < 1.0 || yTransform(dragCurrentYAxis)[3] !== maxYZoom(dragCurrentYAxis))) {\r\n"
  "              tAssign(yTransform(dragCurrentYAxis),\r\n"
  "                  mult(\r\n"
  "                    [1,0,0,yScalePerAxis[dragCurrentYAxis],0,-yScalePerAxis[dragCurrentYAxis]*myBefore+myAfter],\r\n"
  "                    yTransform(dragCurrentYAxis)\r\n"
  "                    )\r\n"
  "                  );\r\n"
  "            }\r\n"
  "          }\r\n"
  "          enforceLimits();\r\n"
  "\r\n"
  "          var crosshairAfter = toDisplayCoord(crosshairBefore, crosshairXAxis(), crosshairYAxis());\r\n"
  "          crosshair[X] = crosshairAfter[X];\r\n"
  "          crosshair[Y] = crosshairAfter[Y];\r\n"
  "\r\n"
  "          touches = newTouches;\r\n"
  "          refreshPenColors();\r\n"
  "          repaint();\r\n"
  "          notifyAreaChanged();\r\n"
  "        }\r\n"
  "        moveTimeout = null;\r\n"
  "      }, 1);\r\n"
  "    };\r\n"
  "\r\n"
  "    function refreshPenColors() {\r\n"
  "      var i, j;\r\n"
  "      for (var xAx = 0; xAx < len(pens().x); ++xAx) {\r\n"
  "        var xLevel = toZoomLevel(xTransform(xAx)[0]) - 1;\r\n"
  "        if (xTransform(xAx)[0] == maxXZoom(xAx))\r\n"
  "          xLevel = len(pens().x[xAx]) - 1;\r\n"
  "        if (xLevel >= len(pens().x[xAx]))\r\n"
  "          xLevel = len(pens().x[xAx]) - 1;\r\n"
  "        for (i = 0; i < len(pens().x[xAx]); ++i) {\r\n"
  "          if (xLevel === i) {\r\n"
  "            for (j = 0; j < len(pens().x[xAx][i]); ++j) {\r\n"
  "              pens().x[xAx][i][j].color[3] = penAlpha().x[xAx][j];\r\n"
  "            }\r\n"
  "          } else {\r\n"
  "            for (j = 0; j < len(pens().x[xAx][i]); ++j) {\r\n"
  "              pens().x[xAx][i][j].color[3] = 0;\r\n"
  "            }\r\n"
  "          }\r\n"
  "        }\r\n"
  "      }\r\n"
  "      for (var yAx = 0; yAx < len(pens().y); ++yAx) {\r\n"
  "        var yLevel = toZoomLevel(yTransform(yAx)[3]) - 1;\r\n"
  "        if (yTransform(yAx)[3] == maxYZoom(yAx))\r\n"
  "          yLevel = len(pens().y[yAx]) - 1;\r\n"
  "        if (yLevel >= len(pens().y[yAx]))\r\n"
  "          yLevel = len(pens().y[yAx]) - 1;\r\n"
  "        for (i = 0; i < len(pens().y[yAx]); ++i) {\r\n"
  "          if (yLevel === i) {\r\n"
  "            for (j = 0; j < len(pens().y[yAx][i]); ++j) {\r\n"
  "              pens().y[yAx][i][j].color[3] = penAlpha().y[yAx][j];\r\n"
  "            }\r\n"
  "          } else {\r\n"
  "            for (j = 0; j < len(pens().y[yAx][i]); ++j) {\r\n"
  "              pens().y[yAx][i][j].color[3] = 0;\r\n"
  "            }\r\n"
  "          }\r\n"
  "        }\r\n"
  "      }\r\n"
  "    }\r\n"
  "\r\n"
  "    function translate(d, flags, matchedXAxis, matchedYAxis) {\r\n"
  "      if (isUndefined(flags))\r\n"
  "        flags = 0;\r\n"
  "      if (isUndefined(matchedXAxis))\r\n"
  "        matchedXAxis = -1;\r\n"
  "      if (isUndefined(matchedYAxis))\r\n"
  "        matchedYAxis = -1;\r\n"
  "      var crosshairBefore = toModelCoord(crosshair, crosshairXAxis(), crosshairYAxis());\r\n"
  "\r\n"
  "      if (isHorizontal()) {\r\n"
  "        d = {x:d.y,y:-d.x};\r\n"
  "      }\r\n"
  "\r\n"
  "      if (flags & NO_LIMIT) {\r\n"
  "        if (matchedXAxis !== -1) {\r\n"
  "          xTransform(matchedXAxis)[4] = xTransform(matchedXAxis)[4] + d.x;\r\n"
  "        } else if (matchedYAxis === -1) {\r\n"
  "          for (var xAx = 0; xAx < xAxisCount(); ++xAx)\r\n"
  "            xTransform(xAx)[4] = xTransform(xAx)[4] + d.x;\r\n"
  "          for (var yAx = 0; yAx < yAxisCount(); ++yAx)\r\n"
  "            yTransform(yAx)[5] = yTransform(yAx)[5] - d.y;\r\n"
  "        } else {\r\n"
  "          yTransform(matchedYAxis)[5] = yTransform(matchedYAxis)[5] - d.y;\r\n"
  "        }\r\n"
  "        setTransformChangedTimeout();\r\n"
  "      } else if (flags & DAMPEN) {\r\n"
  "        var area;\r\n"
  "        if (matchedXAxis !== -1) {\r\n"
  "          area = transformedInsideChartArea(matchedXAxis, 0);\r\n"
  "        } else if (matchedYAxis === -1) {\r\n"
  "          area = transformedInsideChartArea(0, 0);\r\n"
  "          for (var xAx = 1; xAx < xAxisCount(); ++xAx) {\r\n"
  "            area = intersection(are";
  const char * WCartesianChart_js2 = "a, transformedInsideChartArea(xAx, 0));\r\n"
  "          }\r\n"
  "          for (var yAx = 1; yAx < yAxisCount(); ++yAx) {\r\n"
  "            area = intersection(area, transformedInsideChartArea(0, yAx));\r\n"
  "          }\r\n"
  "        } else {\r\n"
  "          area = transformedInsideChartArea(0, matchedYAxis);\r\n"
  "        }\r\n"
  "        if (left(area) > left(insideArea())) {\r\n"
  "          if (d.x > 0) {\r\n"
  "            d.x = d.x / (1 + ((left(area) - left(insideArea())) * RESISTANCE_FACTOR));\r\n"
  "          }\r\n"
  "        } else if (right(area) < right(insideArea())) {\r\n"
  "          if (d.x < 0) {\r\n"
  "            d.x = d.x / (1 + ((right(insideArea()) - right(area)) * RESISTANCE_FACTOR));\r\n"
  "          }\r\n"
  "        }\r\n"
  "        if (top(area) > top(insideArea())) {\r\n"
  "          if (d.y > 0) {\r\n"
  "            d.y = d.y / (1 + ((top(area) - top(insideArea())) * RESISTANCE_FACTOR));\r\n"
  "          }\r\n"
  "        } else if (bottom(area) < bottom(insideArea())) {\r\n"
  "          if (d.y < 0) {\r\n"
  "            d.y = d.y / (1 + ((bottom(insideArea()) - bottom(area)) * RESISTANCE_FACTOR));\r\n"
  "          }\r\n"
  "        }\r\n"
  "        if (matchedXAxis !== -1) {\r\n"
  "          xTransform(matchedXAxis)[4] = xTransform(matchedXAxis)[4] + d.x;\r\n"
  "        } else if (matchedYAxis === -1) {\r\n"
  "          for (var xAx = 0; xAx < xAxisCount(); ++xAx)\r\n"
  "            xTransform(xAx)[4] = xTransform(xAx)[4] + d.x;\r\n"
  "          for (var yAx = 0; yAx < yAxisCount(); ++yAx)\r\n"
  "            yTransform(yAx)[5] = yTransform(yAx)[5] - d.y;\r\n"
  "        } else {\r\n"
  "          yTransform(matchedYAxis)[5] = yTransform(matchedYAxis)[5] - d.y;\r\n"
  "        }\r\n"
  "        if (matchedYAxis === -1)\r\n"
  "          crosshair[X] = crosshair[X] + d.x;\r\n"
  "        if (matchedXAxis === -1)\r\n"
  "          crosshair[Y] = crosshair[Y] + d.y;\r\n"
  "        setTransformChangedTimeout();\r\n"
  "      } else {\r\n"
  "        if (matchedXAxis !== -1) {\r\n"
  "          xTransform(matchedXAxis)[4] = xTransform(matchedXAxis)[4] + d.x;\r\n"
  "        } else if (matchedYAxis === -1) {\r\n"
  "          for (var xAx = 0; xAx < xAxisCount(); ++xAx)\r\n"
  "            xTransform(xAx)[4] = xTransform(xAx)[4] + d.x;\r\n"
  "          for (var yAx = 0; yAx < yAxisCount(); ++yAx)\r\n"
  "            yTransform(yAx)[5] = yTransform(yAx)[5] - d.y;\r\n"
  "        } else {\r\n"
  "          yTransform(matchedYAxis)[5] = yTransform(matchedYAxis)[5] - d.y;\r\n"
  "        }\r\n"
  "        if (matchedYAxis === -1)\r\n"
  "          crosshair[X] = crosshair[X] + d.x;\r\n"
  "        if (matchedXAxis === -1)\r\n"
  "          crosshair[Y] = crosshair[Y] + d.y;\r\n"
  "\r\n"
  "        enforceLimits();\r\n"
  "      }\r\n"
  "\r\n"
  "      var crosshairAfter = toDisplayCoord(crosshairBefore, crosshairXAxis(), crosshairYAxis());\r\n"
  "\r\n"
  "      crosshair[X] = crosshairAfter[X];\r\n"
  "      crosshair[Y] = crosshairAfter[Y];\r\n"
  "\r\n"
  "      repaint();\r\n"
  "      notifyAreaChanged();\r\n"
  "    }\r\n"
  "\r\n"
  "    function zoom(coords, xDelta, yDelta, matchedXAxis, matchedYAxis) {\r\n"
  "      if (isUndefined(matchedXAxis))\r\n"
  "        matchedXAxis = -1;\r\n"
  "      if (isUndefined(matchedYAxis))\r\n"
  "        matchedYAxis = -1;\r\n"
  "      var crosshairBefore = toModelCoord(crosshair, crosshairXAxis(), crosshairYAxis());\r\n"
  "      var xy;\r\n"
  "      if (isHorizontal()) {\r\n"
  "        xy = [coords.y - top(configArea()), coords.x - left(configArea())];\r\n"
  "      } else {\r\n"
  "        xy = mult(\r\n"
  "            inverted([1,0,0,-1,left(configArea()),bottom(configArea())]), [coords.x, coords.y]);\r\n"
  "      }\r\n"
  "      var x = xy[0];\r\n"
  "      var y = xy[1];\r\n"
  "      var s_x = Math.pow(1.2, isHorizontal() ? yDelta : xDelta);\r\n"
  "      var s_y = Math.pow(1.2, isHorizontal() ? xDelta : yDelta);\r\n"
  "      if (matchedXAxis !== -1) {\r\n"
  "        if (xTransform(matchedXAxis)[0] * s_x > maxXZoom(matchedXAxis)) {\r\n"
  "          s_x = maxXZoom(matchedXAxis) / xTransform(matchedXAxis)[0];\r\n"
  "        }\r\n"
  "        if (s_x < 1.0 || xTransform(matchedXAxis)[0] != maxXZoom(matchedXAxis)) {\r\n"
  "          tAssign(xTransform(matchedXAxis), mult([s_x,0,0,1,x-s_x*x,0], xTransform(matchedXAxis)));\r\n"
  "        }\r\n"
  "      } else if (matchedYAxis === -1) {\r\n"
  "        for (var xAx = 0; xAx < xAxisCount(); ++xAx) {\r\n"
  "          var s_specific_x = s_x;\r\n"
  "          if (xTransform(xAx)[0] * s_x > maxXZoom(xAx)) {\r\n"
  "            s_specific_x = maxXZoom(xAx) / xTransform(xAx)[0];\r\n"
  "          }\r\n"
  "          if (s_specific_x < 1.0 || xTransform(xAx)[0] !== maxXZoom(xAx)) {\r\n"
  "            tAssign(xTransform(xAx), mult([s_specific_x,0,0,1,x-s_specific_x*x,0], xTransform(xAx)));\r\n"
  "          }\r\n"
  "        }\r\n"
  "        for (var yAx = 0; yAx < yAxisCount(); ++yAx) {\r\n"
  "          var s_specific_y = s_y;\r\n"
  "          if (yTransform(yAx)[3] * s_y > maxYZoom(yAx)) {\r\n"
  "            s_specific_y = maxYZoom(yAx) / yTransform(yAx)[3];\r\n"
  "          }\r\n"
  "          if (s_specific_y < 1.0 || yTransform(yAx)[3] !== maxYZoom(yAx)) {\r\n"
  "            tAssign(yTransform(yAx), mult([1,0,0,s_specific_y,0,y-s_specific_y*y], yTransform(yAx)));\r\n"
  "          }\r\n"
  "        }\r\n"
  "      } else {\r\n"
  "        if (yTransform(matchedYAxis)[3] * s_y > maxYZoom(matchedYAxis)) {\r\n"
  "          s_y = maxYZoom(matchedYAxis) / yTransform(matchedYAxis)[3];\r\n"
  "        }\r\n"
  "        if (s_y < 1.0 || yTransform(matchedYAxis)[3] != maxYZoom(matchedYAxis)) {\r\n"
  "          tAssign(yTransform(matchedYAxis), mult([1,0,0,s_y,0,y-s_y*y], yTransform(matchedYAxis)));\r\n"
  "        }\r\n"
  "      }\r\n"
  "\r\n"
  "      enforceLimits();\r\n"
  "\r\n"
  "      var crosshairAfter = toDisplayCoord(crosshairBefore, crosshairXAxis(), crosshairYAxis());\r\n"
  "      crosshair[X] = crosshairAfter[X];\r\n"
  "      crosshair[Y] = crosshairAfter[Y];\r\n"
  "\r\n"
  "      refreshPenColors();\r\n"
  "      repaint();\r\n"
  "      notifyAreaChanged();\r\n"
  "    }\r\n"
  "\r\n"
  "    this.setXRange = function(seriesNb, lowerBound, upperBound, updateYAxis) {\r\n"
  "      var xAx = seriesXAxis(seriesNb);\r\n"
  "      var area = modelArea(xAx, 0);\r\n"
  "      lowerBound = area[0] + area[2] * lowerBound;\r\n"
  "      upperBound = area[0] + area[2] * upperBound;\r\n"
  "      //Constrain given range\r\n"
  "      if (left(area) > right(area)) {\r\n"
  "        if (lowerBound > left(area))\r\n"
  "          lowerBound = left(area);\r\n"
  "        if (upperBound < right(area))\r\n"
  "          upperBound = right(area);\r\n"
  "      } else {\r\n"
  "        if (lowerBound < left(area))\r\n"
  "          lowerBound = left(area);\r\n"
  "        if (upperBound > right(area))\r\n"
  "          upperBound = right(area);\r\n"
  "      }\r\n"
  "      // Set X range, and adjust Y!\r\n"
  "      var series = seriesCurve(seriesNb);\r\n"
  "\r\n"
  "      var res = findYRange(series, seriesYAxis(seriesNb), lowerBound, upperBound, isHorizontal(), configArea(), modelArea(seriesXAxis(seriesNb),seriesYAxis(seriesNb)), config.minZoom, config.maxZoom);\r\n"
  "      var xZoom = res.xZoom;\r\n"
  "      var yZoom = res.yZoom;\r\n"
  "      var panPoint = res.panPoint;\r\n"
  "\r\n"
  "      var crosshairBefore = toModelCoord(crosshair, crosshairXAxis(), crosshairYAxis());\r\n"
  "\r\n"
  "      xTransform(seriesXAxis(seriesNb))[0] = xZoom;\r\n"
  "      if (yZoom && updateYAxis)\r\n"
  "        yTransform(seriesYAxis(seriesNb))[3] = yZoom;\r\n"
  "      xTransform(seriesXAxis(seriesNb))[4] = -panPoint[X] * xZoom;\r\n"
  "      if (yZoom && updateYAxis)\r\n"
  "        yTransform(seriesYAxis(seriesNb))[5] = -panPoint[Y] * yZoom;\r\n"
  "      setTransformChangedTimeout();\r\n"
  "\r\n"
  "      var crosshairAfter = toDisplayCoord(crosshairBefore, crosshairXAxis(), crosshairYAxis());\r\n"
  "      crosshair[X] = crosshairAfter[X];\r\n"
  "      crosshair[Y] = crosshairAfter[Y];\r\n"
  "\r\n"
  "      enforceLimits();\r\n"
  "      refreshPenColors();\r\n"
  "      repaint();\r\n"
  "      notifyAreaChanged();\r\n"
  "    }\r\n"
  "\r\n"
  "    this.getSeries = function(seriesNb) {\r\n"
  "      return seriesCurve(seriesNb);\r\n"
  "    }\r\n"
  "\r\n"
  "    this.rangeChangedCallbacks = [];\r\n"
  "\r\n"
  "    this.updateConfig = function(newConfig) {\r\n"
  "      for (var key in newConfig) {\r\n"
  "        if (newConfig.hasOwnProperty(key)) {\r\n"
  "          config[key] = newConfig[key];\r\n"
  "        }\r\n"
  "      }\r\n"
  "      init();\r\n"
  "      refreshPenColors();\r\n"
  "      repaint();\r\n"
  "      notifyAreaChanged();\r\n"
  "    }\r\n"
  "\r\n"
  "    this.updateConfig({});\r\n"
  "\r\n"
  "    if (window.TouchEvent && !window.MSPointerEvent && !window.PointerEvent) {\r\n"
  "      self.touchStart = touchHandlers.start;\r\n"
  "      self.touchEnd = touchHandlers.end;\r\n"
  "      self.touchMoved = touchHandlers.moved;\r\n"
  "    } else {\r\n"
  "      var nop = function(){};\r\n"
  "      self.touchStart = nop;\r\n"
  "      self.touchEnd = nop;\r\n"
  "      self.touchMoved = nop;\r\n"
  "    }\r\n"
  "  });\r\n"
  "";
  std::vector<const char *> WCartesianChart_js()
  {
    std::vector<const char *> retval;

    retval.push_back(WCartesianChart_js1);

    retval.push_back(WCartesianChart_js2);

    return retval;
  }
}