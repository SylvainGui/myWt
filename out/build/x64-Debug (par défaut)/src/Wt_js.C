// This is automatically generated code -- do not edit!
// Generated from  
#include <vector>
namespace skeletons
{


  const char * Wt_js1 = "\r\n"
  "/**\r\n"
  " * @preserve Copyright (C) 2010 Emweb bv, Herent, Belgium.\r\n"
  " *\r\n"
  " * For terms of use, see LICENSE.\r\n"
  " */\r\n"
  "_$_$if_DYNAMIC_JS_$_();\r\n"
  "window.JavaScriptFunction = 1;\r\n"
  "window.JavaScriptConstructor = 2;\r\n"
  "window.JavaScriptObject = 3;\r\n"
  "window.JavaScriptPrototype = 4;\r\n"
  "window.WT_DECLARE_WT_MEMBER = function(i, type, name, fn)\r\n"
  "{\r\n"
  "  if (type == JavaScriptPrototype) {\r\n"
  "    var proto = name.indexOf('.prototype');\r\n"
  "    _$_WT_CLASS_$_[name.substr(0, proto)]\r\n"
  "      .prototype[name.substr(proto + '.prototype.'.length)] = fn;\r\n"
  "  } else if (type == JavaScriptFunction) {\r\n"
  "    _$_WT_CLASS_$_[name] = function() {\r\n"
  "	return fn.apply(_$_WT_CLASS_$_, arguments);\r\n"
  "    };\r\n"
  "  } else {\r\n"
  "    _$_WT_CLASS_$_[name] = fn;\r\n"
  "  }\r\n"
  "};\r\n"
  "window.WT_DECLARE_WT_MEMBER_BIG = window.WT_DECLARE_WT_MEMBER;\r\n"
  "\r\n"
  "window.WT_DECLARE_APP_MEMBER = function(i, type, name, fn)\r\n"
  "{\r\n"
  "  var app = window.currentApp;\r\n"
  "  if (type == JavaScriptPrototype) {\r\n"
  "    var proto = name.indexOf('.prototype');\r\n"
  "    app[name.substr(0, proto)]\r\n"
  "      .prototype[name.substr(proto + '.prototype.'.length)] = fn;\r\n"
  "  } else if (type == JavaScriptFunction) {\r\n"
  "    app[name] = function() { return fn.apply(app, arguments); };\r\n"
  "  } else {\r\n"
  "    app[name] = fn;\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "_$_$endif_$_();\r\n"
  "\r\n"
  "_$_$ifnot_DYNAMIC_JS_$_();\r\n"
  "window.JavaScriptConstructor = 2;\r\n"
  "window.WT_DECLARE_WT_MEMBER_BIG = function(i, type, name, fn)\r\n"
  "{\r\n"
  "  return fn;\r\n"
  "}\r\n"
  "_$_$endif_$_();\r\n"
  "\r\n"
  "if (!window._$_WT_CLASS_$_)\r\n"
  "  window._$_WT_CLASS_$_ = new (function()\r\n"
  "{\r\n"
  "var WT = this;\r\n"
  "/** @const */ var UNDEFINED = 'undefined';\r\n"
  "/** @const */ var UNKNOWN = 'unknown'; // seen on IE for reasons unknown\r\n"
  "\r\n"
  "this.condCall = function(o, f, a) {\r\n"
  "  if (o[f])\r\n"
  "    o[f](a);\r\n"
  "};\r\n"
  "\r\n"
  "// buttons currently down\r\n"
  "this.buttons = 0;\r\n"
  "\r\n"
  "// button last released (for reporting in IE's click event)\r\n"
  "var lastButtonUp = 0, mouseDragging = 0;\r\n"
  "\r\n"
  "// returns the button associated with the event (0 if none)\r\n"
  "this.button = function(e)\r\n"
  "{\r\n"
  "  try {\r\n"
  "    var t = e.type;\r\n"
  "\r\n"
  "    if (WT.isIE && (t == \"click\" || t == \"dblclick\"))\r\n"
  "      return lastButtonUp; // IE does not provide button information then\r\n"
  "\r\n"
  "    if (t != \"mouseup\" && t != \"mousedown\" && t != \"click\" && t != \"dblclick\")\r\n"
  "      return 0;\r\n"
  "  } catch (e) {\r\n"
  "    return 0;\r\n"
  "  }\r\n"
  "\r\n"
  "  if (WT.isIElt9) {\r\n"
  "    if (e.button == 2)\r\n"
  "      return 4;\r\n"
  "    else if (e.button == 4)\r\n"
  "      return 2;\r\n"
  "    else if (e.button == 1)\r\n"
  "      return 1;\r\n"
  "    else\r\n"
  "      return 0;\r\n"
  "  } else {\r\n"
  "    if (e.button == 0)\r\n"
  "      return 1;\r\n"
  "    else if (e.button == 1)\r\n"
  "      return 2;\r\n"
  "    else if (e.button == 2)\r\n"
  "      return 4;\r\n"
  "    else\r\n"
  "      return 0;\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "\r\n"
  "this.mouseDown = function(e) {\r\n"
  "  WT.buttons |= WT.button(e);\r\n"
  "};\r\n"
  "\r\n"
  "this.mouseUp = function(e) {\r\n"
  "  lastButtonUp = WT.button(e);\r\n"
  "  WT.buttons &= ~lastButtonUp;\r\n"
  "\r\n"
  "  /*\r\n"
  "   * mouse click will follow immediately and should still see the old\r\n"
  "   * value of mouseDragging\r\n"
  "   */\r\n"
  "  setTimeout(function() {\r\n"
  "    mouseDragging = 0;\r\n"
  "  }, 5);\r\n"
  "};\r\n"
  "\r\n"
  "/*\r\n"
  " * Used to prevent a mouse click if we're actually dragging\r\n"
  " */\r\n"
  "this.dragged = function(e) {\r\n"
  "  return mouseDragging > 2;\r\n"
  "};\r\n"
  "\r\n"
  "this.drag = function(e) {\r\n"
  "  ++mouseDragging;\r\n"
  "};\r\n"
  "\r\n"
  "/**\r\n"
  " * @preserve Includes Array Remove - By John Resig (MIT Licensed)\r\n"
  " */\r\n"
  "this.arrayRemove = function(a, from, to) {\r\n"
  "  var rest = a.slice((to || from) + 1 || a.length);\r\n"
  "  a.length = from < 0 ? a.length + from : from;\r\n"
  "  return a.push.apply(a, rest);\r\n"
  "};\r\n"
  "\r\n"
  "this.addAll = function(a1, a2) {\r\n"
  "  for (var i = 0, il = a2.length; i < il; ++i)\r\n"
  "    a1.push(a2[i]);\r\n"
  "};\r\n"
  "\r\n"
  "var ie = (function(){\r\n"
  "    var undef,\r\n"
  "        v = 3,\r\n"
  "        div = document.createElement('div'),\r\n"
  "        all = div.getElementsByTagName('i');\r\n"
  "\r\n"
  "    while (\r\n"
  "        div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->',\r\n"
  "        all[0]\r\n"
  "    ) {}\r\n"
  "\r\n"
  "    return v > 4 ? v : undef;\r\n"
  "}());\r\n"
  "\r\n"
  "var agent = navigator.userAgent.toLowerCase();\r\n"
  "\r\n"
  "this.isIE = ie !== undefined;\r\n"
  "this.isIE6 = ie === 6;\r\n"
  "this.isIE8 = ie === 8;\r\n"
  "this.isIElt9 = ie < 9;\r\n"
  "this.isIEMobile = agent.indexOf(\"msie 4\")!=-1 || agent.indexOf(\"msie 5\")!=-1;\r\n"
  "this.isOpera = typeof window.opera !== UNDEFINED;\r\n"
  "this.isAndroid = (agent.indexOf(\"safari\") != -1)\r\n"
  "		  && (agent.indexOf(\"android\") != -1);\r\n"
  "this.isWebKit = (agent.indexOf(\"applewebkit\") != -1);\r\n"
  "this.isGecko = agent.indexOf(\"gecko\") != -1 && !this.isWebKit;\r\n"
  "this.isIOS = agent.indexOf(\"iphone\") != -1 || agent.indexOf(\"ipad\") != -1 || agent.indexOf(\"ipod\") != -1;\r\n"
  "\r\n"
  "this.updateDelay = this.isIE ? 10 : 51;\r\n"
  "\r\n"
  "if (this.isAndroid) {\r\n"
  "  console.error('init console.error');\r\n"
  "  console.info('init console.info');\r\n"
  "  console.log('init console.log');\r\n"
  "  console.warn('init console.warn');\r\n"
  "}\r\n"
  "\r\n"
  "var traceStart = new Date();\r\n"
  "this.trace = function(v, start) {\r\n"
  "  if (start)\r\n"
  "    traceStart = new Date();\r\n"
  "  var now = new Date();\r\n"
  "\r\n"
  "  var diff = (now.getMinutes() - traceStart.getMinutes()) * 60000\r\n"
  "    + (now.getSeconds() - traceStart.getSeconds()) * 1000\r\n"
  "    + (now.getMilliseconds() - traceStart.getMilliseconds());\r\n"
  "\r\n"
  "  if (window.console)\r\n"
  "    console.log(\"[\" + diff + \"]: \" + v);\r\n"
  "};\r\n"
  "\r\n"
  "function host(url) {\r\n"
  "  var parts = url.split('/');\r\n"
  "  return parts[2];\r\n"
  "}\r\n"
  "\r\n"
  "this.initAjaxComm = function(url, handler) {\r\n"
  "  var crossDomain = \r\n"
  "    (url.indexOf(\"://\") != -1 || url.indexOf(\"//\") == 0) &&\r\n"
  "    host(url) != window.location.host;\r\n"
  "\r\n"
  "  function createRequest(method, url) {\r\n"
  "    var request = null;\r\n"
  "    var supportsRequestHeader = true;\r\n"
  "    if (window.XMLHttpRequest) {\r\n"
  "      request = new XMLHttpRequest();\r\n"
  "      if (crossDomain) {\r\n"
  "	if (\"withCredentials\" in request) {\r\n"
  "	  if (url) {\r\n"
  "	    request.open(method, url, true);\r\n"
  "	    request.withCredentials = \"true\";\r\n"
  "	  }\r\n"
  "	} else if (typeof XDomainRequest != \"undefined\") {\r\n"
  "	  request = new XDomainRequest();\r\n"
  "	  if (url) {\r\n"
  "	    supportsRequestHeader = false;\r\n"
  "	    try {\r\n"
  "	      request.open(method, url + '&contentType=x-www-form-urlencoded');\r\n"
  "	    } catch (err) {\r\n"
  "	      request = null;\r\n"
  "	    }\r\n"
  "	  }\r\n"
  "	} else\r\n"
  "	  request = null;\r\n"
  "      } else\r\n"
  "	if (url)\r\n"
  "	  request.open(method, url, true);\r\n"
  "    } else if (!crossDomain && window.ActiveXObject) {\r\n"
  "      try {\r\n"
  "	request = new ActiveXObject(\"Msxml2.XMLHTTP\");\r\n"
  "      } catch (err) {\r\n"
  "	try {\r\n"
  "	  request = new ActiveXObject(\"Microsoft.XMLHTTP\");\r\n"
  "	} catch (err2) {\r\n"
  "	}\r\n"
  "      }\r\n"
  "      if (url && request)\r\n"
  "	request.open(method, url, true);\r\n"
  "    }\r\n"
  "\r\n"
  "    if (request && url && supportsRequestHeader)\r\n"
  "      request.setRequestHeader(\"Content-type\",\r\n"
  "			       \"application/x-www-form-urlencoded\");\r\n"
  "\r\n"
  "    return request;\r\n"
  "  }\r\n"
  "\r\n"
  "  var req = createRequest('POST', url);\r\n"
  "\r\n"
  "  if (req != null) {\r\n"
  "    return new (function() {\r\n"
  "      var sessionUrl = url;\r\n"
  "\r\n"
  "      function Request(data, userData, id, timeout) {\r\n"
  "	var request = createRequest('POST', sessionUrl);\r\n"
  "	var timer = null;\r\n"
  "	var handled = false;\r\n"
  "\r\n"
  "	function handleResponse(good) {\r\n"
  "	  if (handled)\r\n"
  "	    return;\r\n"
  "\r\n"
  "	  clearTimeout(timer);\r\n"
  "\r\n"
  "	  if (!sessionUrl)\r\n"
  "	    return;\r\n"
  "\r\n"
  "	  handled = true;\r\n"
  "\r\n"
  "	  var rq = request;\r\n"
  "	  if (request) {\r\n"
  "	    request.onreadystatechange = new Function;\r\n"
  "	    try {\r\n"
  "	      request.onload = request.onreadystatechange;\r\n"
  "	    } catch (e) {\r\n"
  "	      /*\r\n"
  "	       * See comment below.\r\n"
  "	       */\r\n"
  "	    }\r\n"
  "	    request = null;\r\n"
  "	  }\r\n"
  "\r\n"
  "	  if (good) {\r\n"
  "	    handler(0, rq.responseText, userData);\r\n"
  "	  } else {\r\n"
  "	    handler(1, null, userData); \r\n"
  "	  }\r\n"
  "	}\r\n"
  "\r\n"
  "	function recvCallback() {\r\n"
  "	  if (request.readyState == 4) {\r\n"
  "	    var good = request.status == 200\r\n"
  "	      && request.getResponseHeader(\"Content-Type\")\r\n"
  "	      && request.getResponseHeader(\"Content-Type\")\r\n"
  "		.indexOf(\"text/javascript\") == 0;\r\n"
  "\r\n"
  "	    handleResponse(good);\r\n"
  "	  }\r\n"
  "	}\r\n"
  "\r\n"
  "	function handleTimeout() {\r\n"
  "	  if (handled)\r\n"
  "	    return;\r\n"
  "\r\n"
  "	  if (!sessionUrl)\r\n"
  "	    return;\r\n"
  "\r\n"
  "	  request.onreadystatechange = new Function;\r\n"
  "	  request = null;\r\n"
  "	  handled = true;\r\n"
  "	  handler(2, null, userData);\r\n"
  "	}\r\n"
  "\r\n"
  "	this.abort = function() {\r\n"
  "	  if (request != null) {\r\n"
  "	    request.onreadystatechange = new Function;\r\n"
  "	    handled = true;\r\n"
  "	    request.abort();\r\n"
  "	    request = null;\r\n"
  "	  }\r\n"
  "	};\r\n"
  "\r\n"
  "	if (_$_CLOSE_CONNECTION_$_)\r\n"
  "	  request.setRequestHeader(\"Connection\",\"close\");\r\n"
  "\r\n"
  "	if (timeout > 0)\r\n"
  "	  timer = setTimeout(handleTimeout, timeout);\r\n"
  "	  request.onreadystatechange = recvCallback;\r\n"
  "	  try {\r\n"
  "	    request.onload = function() {\r\n"
  "	      handleResponse(true);\r\n"
  "	    };\r\n"
  "	    request.onerror = function() {\r\n"
  "	      handleResponse(false);\r\n"
  "	    };\r\n"
  "	  } catch (e) {\r\n"
  "	    /*\r\n"
  "	     * On IE, when \"Enable Native XMLHTTP Support is unchecked\",\r\n"
  "	     * setting these members will result in an exception.\r\n"
  "	     */\r\n"
  "	  }\r\n"
  "	request.send(data);\r\n"
  "      }\r\n"
  "\r\n"
  "      this.responseReceived = function(updateId) { };\r\n"
  "\r\n"
  "      this.sendUpdate = function(data, userData, id, timeout) {\r\n"
  "	if (!sessionUrl)\r\n"
  "	  return null;\r\n"
  "	return new Request(data, userData, id, timeout);\r\n"
  "      };\r\n"
  "\r\n"
  "      this.cancel = function() {\r\n"
  "	sessionUrl = null;\r\n"
  "      };\r\n"
  "\r\n"
  "      this.setUrl = function(url) {\r\n"
  "	sessionUrl = url;\r\n"
  "      };\r\n"
  "    })();\r\n"
  "  } else {\r\n"
  "    return new (function() {\r\n"
  "      var sessionUrl = url;\r\n"
  "      var request = null;\r\n"
  "\r\n"
  "      function Request(data, userData, id, timeout) {\r\n"
  "	var self = this;\r\n"
  "\r\n"
  "	this.userData = userData;\r\n"
  "\r\n"
  "	var s = this.script = document.createElement('script');\r\n"
  "	s.id = \"script\" + id;\r\n"
  "	s.setAttribute('src', sessionUrl + '&' + data);\r\n"
  "\r\n"
  "	function onerror() {\r\n"
  "	  handler(1, null, userData);\r\n"
  "	  s.parentNode.removeChild(s);\r\n"
  "	}\r\n"
  "\r\n"
  "	s.onerror = onerror;\r\n"
  "\r\n"
  "	var h = document.getElementsByTagName('head')[0];\r\n"
  "	h.appendChild(s);\r\n"
  "\r\n"
  "	this.abort = function() {\r\n"
  "	  s.parentNode.removeChild(s);\r\n"
  "	};\r\n"
  "      }\r\n"
  "\r\n"
  "      this.responseReceived = function(updateId) {\r\n"
  "        if (request != null) {\r\n"
  "          var req = request;\r\n"
  "	  request.script.parentNode.removeChild(request.script);\r\n"
  "          request = null;\r\n"
  "	  handler(0, \"\", req.userData);\r\n"
  "	}\r\n"
  "      };\r\n"
  "\r\n"
  "      this.sendUpdate = function(data, userData, id, timeout) {\r\n"
  "	if (!sessionUrl)\r\n"
  "	  return null;\r\n"
  "        request = new Request(data, userData, id, timeout);\r\n"
  "        return request;\r\n"
  "      };\r\n"
  "\r\n"
  "      this.cancel = function() {\r\n"
  "	sessionUrl = null;\r\n"
  "      };\r\n"
  "\r\n"
  "      this.setUrl = function(url) {\r\n"
  "	sessionUrl = url;\r\n"
  "      };\r\n"
  "\r\n"
  "    })();\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "this.setHtml = function (el, html, add) {\r\n"
  "  function myImportNode(e, deep) {\r\n"
  "    var newNode, i, il;\r\n"
  "    switch (e.nodeType) {\r\n"
  "    case 1: // element\r\n"
  "      if (e.namespaceURI === null)\r\n"
  "	newNode = document.createElement(e.nodeName);\r\n"
  "      else\r\n"
  "	newNode = document.createElementNS(e.namespaceURI, e.nodeName);\r\n"
  "      if (e.attributes && e.attributes.length > 0)\r\n"
  "	for (i = 0, il = e.attributes.length; i < il;)\r\n"
  "	  newNode.setAttribute(e.attributes[i].nodeName,\r\n"
  "			       e.getAttribute(e.attributes[i++].nodeName));\r\n"
  "      if (deep && e.childNodes.length > 0)\r\n"
  "	for (i = 0, il = e.childNodes.length; i < il;) {\r\n"
  "	  var c = myImportNode(e.childNodes[i++], deep);\r\n"
  "	  if (c)\r\n"
  "	    newNode.appendChild(c);\r\n"
  "	}\r\n"
  "      return newNode;\r\n"
  "      break;\r\n"
  "    case 3: // text\r\n"
  "    case 4: // cdata\r\n"
  "    case 5: // comment\r\n"
  "      return document.createTextNode(e.nodeValue);\r\n"
  "      break;\r\n"
  "    }\r\n"
  "\r\n"
  "    return null;\r\n"
  "  }\r\n"
  "\r\n"
  "  if (WT.isIE || (_$_INNER_HTML_$_ && !add)) {\r\n"
  "    if (add)\r\n"
  "      el.innerHTML += html;\r\n"
  "    else {\r\n"
  "      WT.saveReparented(el);\r\n"
  "      el.innerHTML = html;\r\n"
  "    }\r\n"
  "  } else {\r\n"
  "    var d, b;\r\n"
  "    d = new DOMParser();\r\n"
  "    b = d.parseFromString('<div>'+html+'<\\/div>','application/xhtml+xml');\r\n"
  "    d = b.documentElement;\r\n"
  "    if (d.nodeType != 1) // element\r\n"
  "      d = d.nextSibling;\r\n"
  "\r\n"
  "    if (!add) {\r\n"
  "      WT.saveReparented(el);\r\n"
  "      el.innerHTML = '';\r\n"
  "    }\r\n"
  "\r\n"
  "    for (var i = 0, il = d.childNodes.length; i < il;)\r\n"
  "      el.appendChild(myImportNode(d.childNodes[i++], true));\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "this.hasTag = function(e, s) {\r\n"
  "  return e.nodeType == 1 && e.tagName && e.tagName.toUpperCase() === s;\r\n"
  "};\r\n"
  "\r\n"
  "this.insertAt = function(p, c, pos) {\r\n"
  "  if (!p.childNodes.length)\r\n"
  "    p.appendChild(c);\r\n"
  "  else {\r\n"
  "    var i, j, il;\r\n"
  "    for (i = 0, j = 0, il = p.childNodes.length; i < il; ++i) {\r\n"
  "      if ($(p.childNodes[i]).hasClass(\"wt-reparented\"))\r\n"
  "         continue;\r\n"
  "      if (j === pos) {\r\n"
  "          p.insertBefore(c, p.childNodes[i]);\r\n"
  "          return;\r\n"
  "      }\r\n"
  "      ++j;\r\n"
  "    }\r\n"
  "    p.appendChild(c);\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "this.remove = function(id)\r\n"
  "{\r\n"
  "  var e = WT.getElement(id);\r\n"
  "  if (e) {\r\n"
  "    WT.saveReparented(e);\r\n"
  "    e.parentNode.removeChild(e);\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "this.replaceWith = function(w1Id, $w2)\r\n"
  "{\r\n"
  "  var $w1 = $(\"#\" + w1Id);\r\n"
  "  $w1.replaceWith($w2);\r\n"
  "\r\n"
  "  /* Reapply client-side validation, bootstrap applys validation classes\r\n"
  "     also outside the element into its ancestors */\r\n"
  "  if ($w2.get(0).wtValidate && WT.validate) {\r\n"
  "    setTimeout(function() { \r\n"
  "      WT.validate($w2.get(0));\r\n"
  "    }, 0);\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "this.contains = function(w1, w2) {\r\n"
  "  var p = w2.parentNode;\r\n"
  "\r\n"
  "  while (p && !WT.hasTag(p, \"BODY\")) {\r\n"
  "    if (p == w1)\r\n"
  "      return true;\r\n"
  "    p = p.parentNode;\r\n"
  "  }\r\n"
  "\r\n"
  "  return false;\r\n"
  "};\r\n"
  "\r\n"
  "this.unstub = function(from, to, methodDisplay) {\r\n"
  "  if (methodDisplay == 1) {\r\n"
  "    if (from.style.display != 'none')\r\n"
  "      to.style.display = from.style.display;\r\n"
  "  } else {\r\n"
  "    to.style.position = from.style.position;\r\n"
  "    to.style.left = from.style.left;\r\n"
  "    to.style.visibility = from.style.visibility;\r\n"
  "  }\r\n"
  "\r\n"
  "  if (from.style.height)\r\n"
  "    to.style.height = from.style.height;\r\n"
  "  if (from.style.width)\r\n"
  "    to.style.width = from.style.width;\r\n"
  "\r\n"
  "  to.style.boxSizing = from.style.boxSizing;\r\n"
  "  var attrName = WT.styleAttribute('box-sizing');\r\n"
  "  var vendorPrefix = WT.vendorPrefix(attrName);\r\n"
  "  if (vendorPrefix)\r\n"
  "    to.style[attrName] = from.style[attrName];\r\n"
  "};\r\n"
  "\r\n"
  "this.saveReparented = function(el) {\r\n"
  "  $(el).find('.wt-reparented').each(function() {\r\n"
  "      var domRoot = $('.Wt-domRoot').get(0);\r\n"
  "      domRoot.appendChild(this.parentNode.removeChild(this));\r\n"
  "    });\r\n"
  "};\r\n"
  "\r\n"
  "this.changeTag = function(e, type)\r\n"
  "{\r\n"
  "  var n = document.createElement(type);\r\n"
  "\r\n"
  "   /* For some reason fails on 'a' */\r\n"
  "  if (type == 'img' && n.mergeAttributes) {\r\n"
  "    n.mergeAttributes(e, false);\r\n"
  "    n.src = e.src;\r\n"
  "  } else {\r\n"
  "    if (e.attributes && e.attributes.length > 0) {\r\n"
  "      var i, il;\r\n"
  "      for (i = 0, il = e.attributes.length; i < il; i++) {\r\n"
  "	var nn = e.attributes[i].nodeName;\r\n"
  "	if (nn != 'type' && nn != 'name')\r\n"
  "	  n.setAttribute(nn, e.getAttribute(nn));\r\n"
  "      }\r\n"
  "    }\r\n"
  "  }\r\n"
  "\r\n"
  "  while (e.firstChild)\r\n"
  "    n.appendChild(e.removeChild(e.firstChild));\r\n"
  "\r\n"
  "  e.parentNode.replaceChild(n, e);\r\n"
  "};\r\n"
  "\r\n"
  "this.unwrap = function(e) {\r\n"
  "  e = WT.getElement(e);\r\n"
  "  if (!e.parentNode.className.indexOf('Wt-wrap')) {\r\n"
  "    var wrapped = e;\r\n"
  "    e = e.parentNode;\r\n"
  "    if (e.className.length >= 8)\r\n"
  "      wrapped.className = e.className.substring(8);\r\n"
  "    var style = e.getAttribute('style');\r\n"
  "    if (style) {\r\n"
  "      if (WT.isIE)\r\n"
  "	wrapped.style.setAttribute('cssText', style);\r\n"
  "      else\r\n"
  "	wrapped.setAttribute('style', style);\r\n"
  "    }\r\n"
  "    e.parentNode.replaceChild(wrapped, e);\r\n"
  "  } else {\r\n"
  "    if (e.getAttribute('type') == 'submit') {\r\n"
  "      e.setAttribute('type', 'button');\r\n"
  "      e.removeAttribute('name');\r\n"
  "    } else if (WT.hasTag(e, 'A') && e.href.indexOf('&signal=') != -1) {\r\n"
  "        e.href = 'javascript:void(0)';\r\n"
  "    } if (WT.hasTag(e, 'INPUT') && e.getAttribute('type') == 'image') {\r\n"
  "      WT.changeTag(e, 'img');\r\n"
  "    }\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "this.navigateInternalPath = function(event, path) {\r\n"
  "  var e = event || window.event;\r\n"
  "  if (!e.ctrlKey && !e.metaKey && WT.button(e) <= 1) {\r\n"
  "    WT.history.navigate(path, true);\r\n"
  "    WT.cancelEvent(e, WT.CancelDefaultAction);\r\n"
  "  };\r\n"
  "};\r\n"
  "\r\n"
  "this.ajaxInternalPaths = function(basePath) {\r\n"
  "  $('.Wt-ip').each(function() {\r\n"
  "      var href = this.getAttribute('href'), wtd = href.lastIndexOf('?wtd');\r\n"
  "      if (wtd === -1)\r\n"
  "	wtd = href.lastIndexOf('&wtd');\r\n"
  "      if (wtd !== -1)\r\n"
  "	href = href.substr(0, wtd);\r\n"
  "\r\n"
  "      var internalPath;\r\n"
  "\r\n"
  "      /*\r\n"
  "       * On IE < 8, an absolute URL is read from href. In that case we\r\n"
  "       * also turn the basePath into an absolute URL.\r\n"
  "       */\r\n"
  "      if (href.indexOf(\"://\") != -1) {\r\n"
  "	var el= document.createElement('div');\r\n"
  "	el.innerHTML= '<a href=\"' + basePath +'\">x</a>';\r\n"
  "	var absBase = el.firstChild.href;\r\n"
  "	internalPath = href.substr(absBase.length - 1);\r\n"
  "      } else {\r\n"
  "	while (href.substr(0, 3) == \"../\")\r\n"
  "	  href = href.substr(3);\r\n"
  "	if (href.charAt(0) != '/')\r\n"
  "	  href = '/' + href;\r\n"
  "	internalPath = href.substr(basePath.length);\r\n"
  "	if (internalPath.substr(0, 2) == \"_=\" &&\r\n"
  "	    basePath.charAt(basePath.length - 1) == '?')\r\n"
  "	  internalPath = '?' + internalPath;  /* eaten one too much */\r\n"
  "      }\r\n"
  "\r\n"
  "      if (internalPath.length == 0 || internalPath.charAt(0) != '/')\r\n"
  "	internalPath = '/' + internalPath;\r\n"
  "      if (internalPath.substr(0, 4) == \"/?_=\")\r\n"
  "	internalPath = internalPath.substr(4);\r\n"
  "      this.setAttribute('href', href); // computes this.href\r\n"
  "      this.setAttribute('href', this.href);\r\n"
  "      this.onclick = function(event) {\r\n"
  "	WT.navigateInternalPath(event, internalPath);\r\n"
  "      };\r\n"
  "      $(this).removeClass(\"Wt-ip\");\r\n"
  "    });\r\n"
  "};\r\n"
  "\r\n"
  "this.resolveRelativeAnchors = function() {\r\n"
  "  if (window.$)\r\n"
  "    $('.Wt-rr').each(function() {\r\n"
  "      if (this.href)\r\n"
  "	this.setAttribute('href', this.href);\r\n"
  "      if (this.src)\r\n"
  "	this.setAttribute('src', this.src);\r\n"
  "\r\n"
  "      $(this).removeClass(\"Wt-rr\");\r\n"
  "    });\r\n"
  "};\r\n"
  "\r\n"
  "var delegating = false;\r\n"
  "\r\n"
  "this.CancelPropagate = 0x1;\r\n"
  "this.CancelDefaultAction = 0x2;\r\n"
  "this.CancelAll = 0x3;\r\n"
  "\r\n"
  "this.cancelEvent = function(e, cancelType) {\r\n"
  "  if (delegating)\r\n"
  "    return;\r\n"
  "\r\n"
  "  var ct = cancelType === undefined ? WT.CancelAll : cancelType;\r\n"
  "\r\n"
  "  if (ct & WT.CancelDefaultAction)\r\n"
  "    if (e.preventDefault)\r\n"
  "      e.preventDefault();\r\n"
  "    else\r\n"
  "      e.returnValue=false;\r\n"
  "\r\n"
  "  if (ct & WT.CancelPropagate) {\r\n"
  "    if (e.stopPropagation)\r\n"
  "      e.stopPropagation();\r\n"
  "    else\r\n"
  "      e.cancelBubble=true;\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "this.getElement = function(id) {\r\n"
  "  var el = document.getElementById(id);\r\n"
  "  if (!el)\r\n"
  "    for (var i = 0; i < window.frames.length; ++i) {\r\n"
  "      try {\r\n"
  "        el = window.frames[i].document.getElementById(id);\r\n"
  "        if (el)\r\n"
  "          return el;\r\n"
  "      } catch (e) {\r\n"
  "      }\r\n"
  "    }\r\n"
  "  return el;\r\n"
  "};\r\n"
  "\r\n"
  "this.$ = this.getElement;\r\n"
  "\r\n"
  "this.filter = function(edit, event, tokens) {\r\n"
  "  var c = String.fromCharCode((typeof event.charCode !== UNDEFINED) ?\r\n"
  "                              event.charCode : event.keyCode);\r\n"
  "  if (!new RegExp(tokens).test(c))\r\n"
  "    WT.cancelEvent(event);\r\n"
  "};\r\n"
  "\r\n"
  "// Get coordinates of element relative to an ancestor object (or page origin).\r\n"
  "// It computes the location of the left-top corner of the margin-box.\r\n"
  "this.widgetPageCoordinates = function(obj, reference) {\r\n"
  "  if (!obj.getBoundingClientRect) {\r\n"
  "    return {x: 0, y: 0};\r\n"
  "  }\r\n"
  "\r\n"
  "  var pageXOffset = window.pageXOffset !== undefined ? window.pageXOffset : document.documentElement.scrollLeft;\r\n"
  "  var pageYOffset = window.pageYOffset !== undefined ? window.pageYOffset : document.documentElement.scrollTop;\r\n"
  "\r\n"
  "  var rect = obj.getBoundingClientRect();\r\n"
  "  var refLeft = -pageXOffset, refTop = -pageYOffset;\r\n"
  "  if (reference) {\r\n"
  "    var refRect = reference.getBoundingClientRect();\r\n"
  "    refLeft = refRect.left;\r\n"
  "    refTop = refRect.top;\r\n"
  "  }\r\n"
  "  return {x: rect.left - refLeft, y: rect.top - refTop};\r\n"
  "};\r\n"
  "\r\n"
  "// Get coordinates of (mouse) event relative to a element.\r\n"
  "this.widgetCoordinates = function(obj, e) {\r\n"
  "  var p = WT.pageCoordinates(e);\r\n"
  "  var w = WT.widgetPageCoordinates(obj);\r\n"
  "  return { x: p.x - w.x, y: p.y - w.y };\r\n"
  "};\r\n"
  "\r\n"
  "// Get coordinates of (mouse) event relative to page origin.\r\n"
  "this.pageCoordinates = function(e) {\r\n"
  "  if (!e) e = window.event;\r\n"
  "\r\n"
  "  var posX = 0, posY = 0;\r\n"
  "\r\n"
  "  var target = e.target || e.srcElement;\r\n"
  "\r\n"
  "  // if this is an iframe, offset against the frame's position\r\n"
  "  if (target && (target.ownerDocument != document))\r\n"
  "    for (var i=0; i < window.frames.length; i++) {\r\n"
  "      if (target.ownerDocument == window.frames[i].document) {\r\n"
  "        try{\r\n"
  "          var rect = window.frames[i].frameElement.getBoundingClientRect();\r\n"
  "          posX = rect.left;\r\n"
  "          posY = rect.top;\r\n"
  "        }catch (e) {\r\n"
  "        }\r\n"
  "      }\r\n"
  "    }\r\n"
  "  \r\n"
  "  if (e.touches && e.touches[0]) {\r\n"
  "    return WT.pageCoordinates(e.touches[0]);\r\n"
  "  } else if (!WT.isIE && e.changedTouches && e.changedTouches[0]) {\r\n"
  "    posX += e.changedTouches[0].pageX;\r\n"
  "    posY += e.changedTouches[0].pageY;\r\n"
  "  } else if (typeof e.pageX === 'number') {\r\n"
  "    posX += e.pageX; posY = e.pageY;\r\n"
  "  } else if (typeof e.clientX === 'number') {\r\n"
  "    posX += e.clientX + document.body.scrollLeft\r\n"
  "      + document.documentElement.scrollLeft;\r\n"
  "    posY += e.clientY + document.body.scrollTop\r\n"
  "      + document.documentElement.scrollTop;\r\n"
  "  }\r\n"
  "\r\n"
  "  return { x: posX, y: posY };\r\n"
  "};\r\n"
  "\r\n"
  "this.windowCoordinates = function(e) {\r\n"
  "  var p = WT.pageCoordinates(e);\r\n"
  "  var cx = p.x - document.body.scrollLeft - document.documentElement.scrollLeft;\r\n"
  "  var cy = p.y - document.body.scrollTop - document.documentElement.scrollTop;\r\n"
  "\r\n"
  "  return { x: cx, y: cy };\r\n"
  "};\r\n"
  "\r\n"
  "/**\r\n"
  " * @preserve Includes normalizeWheel from Fixed Data Tables for React by Facebook (BSD Licensed)\r\n"
  " */\r\n"
  "this.normalizeWheel = function(event) {\r\n"
  "  var PIXEL_STEP = 10;\r\n"
  "  var LINE_HEIGHT = 40;\r\n"
  "  var PAGE_HEIGHT = 800;\r\n"
  "\r\n"
  "  var sX = 0,\r\n"
  "      sY = 0,\r\n"
  "      // spinX, spinY\r\n"
  "  pX = 0,\r\n"
  "      pY = 0; // pixelX, pixelY\r\n"
  "\r\n"
  "  // Legacy\r\n"
  "  if ('detail' in event) {\r\n"
  "    sY = event.detail;\r\n"
  "  }\r\n"
  "  if ('wheelDelta' in event) {\r\n"
  "    sY = -event.wheelDelta / 120;\r\n"
  "  }\r\n"
  "  if ('wheelDeltaY' in event) {\r\n"
  "    sY = -event.wheelDeltaY / 120;\r\n"
  "  }\r\n"
  "  if ('wheelDeltaX' in event) {\r\n"
  "    sX = -event.wheelDeltaX / 120;\r\n"
  "  }\r\n"
  "\r\n"
  "  // side scrolling on FF with DOMMouseScroll\r\n"
  "  if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {\r\n"
  "    sX = sY;\r\n"
  "    sY = 0;\r\n"
  "  }\r\n"
  "\r\n"
  "  pX = sX * PIXEL_STEP;\r\n"
  "  pY = sY * PIXEL_STEP;\r\n"
  "\r\n"
  "  if ('deltaY' in event) {\r\n"
  "    pY = event.deltaY;\r\n"
  "  }\r\n"
  "  if ('deltaX' in event) {\r\n"
  "    pX = event.deltaX;\r\n"
  "  }\r\n"
  "\r\n"
  "  if ((pX || pY) && event.deltaMode) {\r\n"
  "    if (event.deltaMode == 1) {\r\n"
  "      // delta in LINE units\r\n"
  "      pX *= LINE_HEIGHT;\r\n"
  "      pY *= LINE_HEIGHT;\r\n"
  "    } else {\r\n"
  "      // delta in PAGE units\r\n"
  "      pX *= PAGE_HEIGHT;\r\n"
  "      pY *= PAGE_HEIGHT;\r\n"
  "    }\r\n"
  "  }\r\n"
  "\r\n"
  "  // Fall-back if spin cannot be determined\r\n"
  "  if (pX && !sX) {\r\n"
  "    sX = pX < 1 ? -1 : 1;\r\n"
  "  }\r\n"
  "  if (pY && !sY) {\r\n"
  "    sY = pY < 1 ? -1 : 1;\r\n"
  "  }\r\n"
  "\r\n"
  "  return { spinX: sX,\r\n"
  "    spinY: sY,\r\n"
  "    pixelX: pX,\r\n"
  "    pixelY: pY };\r\n"
  "}\r\n"
  "\r\n"
  "this.wheelDelta = function(e) {\r\n"
  "  var delta = 0;\r\n"
  "  if (e.deltaY) { /* WheelEvent */\r\n"
  "    delta = e.deltaY > 0 ? -1 : 1;\r\n"
  "  } else if (e.wheelDelta) { /* IE/Opera. */\r\n"
  "    delta = e.wheelDelta > 0 ? 1 : -1;\r\n"
  "    /* if (window.opera)\r\n"
  "       delta = -delta; */\r\n"
  "  } else if (e.detail) {\r\n"
  "    delta = e.detail < 0 ? 1 : -1;\r\n"
  "  }\r\n"
  "  return delta;\r\n"
  "};\r\n"
  "\r\n"
  "this.scrollHistory = function() {\r\n"
  "  // after any hash change event (forward/backward, or user clicks\r\n"
  "  // on an achor with internal path), the server calls this function\r\n"
  "  // to update the scroll position of the main window\r\n"
  "  try {\r\n"
  "    if (window.history.state) {\r\n"
  "      if (typeof window.history.state.pageXOffset !== UNDEFINED) {\r\n"
  "        // scroll to a historic position where we have been before\r\n"
  "        //console.log(\"scrollHistory: \" + JSON.stringify(window.history.state));\r\n"
  "        window.scrollTo(window.history.state.pageXOffset, window.history.state.pageYOffset);\r\n"
  "      } else {\r\n"
  "        // we went to a new hash (following an anchor, we assume some equivalence\r\n"
  "        // with 'new page') that hasn't been scrolled yet.\r\n"
  "        // Scroll to the top, which may be overriden by scrollIntoView (if the hash\r\n"
  "        // exists somewhere as an object ID)\r\n"
  "        //console.log(\"scrollHistory: new page scroll strategy\");\r\n"
  "        window.scrollTo(0, 0);\r\n"
  "        WT.scrollIntoView(window.history.state.state);\r\n"
  "      }\r\n"
  "    }\r\n"
  "  } catch (error) {\r\n"
  "    console.log(error);\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "this.scrollIntoView = function(id) {\r\n"
  "  var hashI = id.indexOf('#');\r\n"
  "  if (hashI != -1)\r\n"
  "    id = id.substr(hashI + 1);\r\n"
  "\r\n"
  "  var obj = document.getElementById(id);\r\n"
  "  if (obj) {\r\n"
  "    /* Locate a suitable ancestor to scroll */\r\n"
  "    var p;\r\n"
  "    for (p = obj.parentNode; p != document.body; p = p.parentNode) {\r\n"
  "      if (p.scrollHeight > p.clientHeight &&\r\n"
  "          WT.css(p, 'overflow-y') == 'auto') {\r\n"
  "        var xy = WT.widgetPageCoordinates(obj, p);\r\n"
  "        p.scrollTop += xy.y;\r\n"
  "        return;\r\n"
  "      }\r\n"
  "    }\r\n"
  "    obj.scrollIntoView(true);\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "function isHighSurrogate(chr) {\r\n"
  "  return 0xD800 <= chr && chr <= 0xDBFF;\r\n"
  "};\r\n"
  "\r\n"
  "function isLowSurrogate(chr) {\r\n"
  "  return 0xDC00 <= chr && chr <= 0xDFFF;\r\n"
  "};\r\n"
  "\r\n"
  "function toUnicodeSelection(selection, text) {\r\n"
  "  var i;\r\n"
  "  var start = selection.start;\r\n"
  "  var end = selection.end;\r\n"
  "  if (text) {\r\n"
  "    for (i = 0; i < text.length; ++i) {\r\n"
  "      if (i >= selection.start && i >= selection.end)\r\n"
  "	return {start: start, end: end};\r\n"
  "      if (isHighSurrogate(text.charCodeAt(i)) &&\r\n"
  "	  (i + 1) < text.length &&\r\n"
  "	  isLowSurrogate(text.charCodeAt(i + 1))) {\r\n"
  "	if (i < selection.start)\r\n"
  "	  --start;\r\n"
  "	if (i < selection.end)\r\n"
  "	  --end;\r\n"
  "      }\r\n"
  "    }\r\n"
  "  }\r\n"
  "  return {start: start, end: end};\r\n"
  "};\r\n"
  "\r\n"
  "this.getUnicodeSelectionRange = function(elem) {\r\n"
  "  return toUnicodeSelection(WT.getSelectionRange(elem), $(elem).val());\r\n"
  "};\r\n"
  "\r\n"
  "this.getSelectionRange = function(elem) {\r\n"
  "  if (document.selection) { // IE\r\n"
  "    if (WT.hasTag(elem, 'TEXTAREA')) {\r\n"
  "      var sel = document.selection.createRange();\r\n"
  "      var sel2 = sel.duplicate();\r\n"
  "      sel2.moveToElementText(elem);\r\n"
  "\r\n"
  "      var pos = 0;\r\n"
  "      if(sel.text.length > 1) {\r\n"
  "	pos = pos - sel.text.length;\r\n"
  "	if(pos < 0) {\r\n"
  "	  pos = 0;\r\n"
  "	}\r\n"
  "      }\r\n"
  "\r\n"
  "      var caretPos = -1 + pos;\r\n"
  "      sel2.moveStart('character', pos);\r\n"
  "\r\n"
  "      while (sel2.inRange(sel)) {\r\n"
  "	sel2.moveStart('character');\r\n"
  "	caretPos++;\r\n"
  "      }\r\n"
  "\r\n"
  "      var selStr = sel.text.replace(/\\r/g, \"\");\r\n"
  "\r\n"
  "      return {start: caretPos, end: selStr.length + caretPos};\r\n"
  "    } else {\r\n"
  "      var start = -1;\r\n"
  "      var end = -1;\r\n"
  "\r\n"
  "      var val = $(elem).val();\r\n"
  "      if (val) {\r\n"
  "        var range = document.selection.createRange().duplicate();\r\n"
  "\r\n"
  "        range.moveEnd(\"character\", val.length);\r\n"
  "        start = (range.text == \"\" ? val.length : val.lastIndexOf(range.text));\r\n"
  "\r\n"
  "        range = document.selection.createRange().duplicate();\r\n"
  "        range.moveStart(\"character\", -val.length);\r\n"
  "        end = range.text.length;\r\n"
  "      }\r\n"
  "\r\n"
  "      return {start: start, end: end};\r\n"
  "    }\r\n"
  "  } else if (elem.selectionStart || elem.selectionStart == 0) {\r\n"
  "    return {start: elem.selectionStart, end: elem.selectionEnd};\r\n"
  "  } else\r\n"
  "    return {start: -1, end: -1};\r\n"
  "};\r\n"
  "\r\n"
  "this.setUnicodeSelectionRange = function(elem, start, end) {\r\n"
  "  return WT.setSelectionRange(elem, start, end, true);\r\n"
  "};\r\n"
  "\r\n"
  "this.setSelectionRange = function(elem, start, end, unicode) {\r\n"
  "  /**\r\n"
  "   * @preserve Includes jQuery Caret Range plugin\r\n"
  "   * Copyright (c) 2009 Matt Zabriskie\r\n"
  "   * Released under the MIT and GPL licenses.\r\n"
  "   */\r\n"
  "  var val = $(elem).val();\r\n"
  "\r\n"
  "  if (typeof start != \"number\") start = -1;\r\n"
  "  if (typeof end != \"number\") end = -1;\r\n"
  "  if (start < 0) start = 0;\r\n"
  "  if (end > val.length) end = val.length;\r\n"
  "  if (end < start) end = start;\r\n"
  "  if (start > end) start = end;\r\n"
  "\r\n"
  "  elem.focus();\r\n"
  "\r\n"
  "  if (unicode) {\r\n"
  "    var i;\r\n"
  "    for (i = 0; i < val.length; ++i) {\r\n"
  "      if (i >= start && i >= end)\r\n"
  "	break;\r\n"
  "      if (isHighSurrogate(val.charCodeAt(i)) &&\r\n"
  "	  (i + 1) < val.length &&\r\n"
  "	  isLowSurrogate(val.charCodeAt(i + 1))) {\r\n"
  "	if (i < start)\r\n"
  "	  ++start;\r\n"
  "	if (i < end)\r\n"
  "	  ++end;\r\n"
  "      }\r\n"
  "    }\r\n"
  "  }\r\n"
  "  \r\n"
  "  if (typeof elem.selectionStart !== UNDEFINED) {\r\n"
  "    elem.selectionStart = start;\r\n"
  "    elem.selectionEnd = end;\r\n"
  "  }\r\n"
  "  else if (document.selection) {\r\n"
  "    var range = elem.createTextRange();\r\n"
  "    range.collapse(true);\r\n"
  "    range.moveStart(\"character\", start);\r\n"
  "    range.moveEnd(\"character\", end - start);\r\n"
  "    range.select();\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "this.isKeyPress = function(e) {\r\n"
  "  if (!e) e = window.event;\r\n"
  "\r\n"
  "  if (e.ctrlKey || e.metaKey)\r\n"
  "    return false;\r\n"
  "\r\n"
  "  var charCode = (typeof e.charCode !== UNDEFINED) ? e.charCode : 0;\r\n"
  "\r\n"
  "  if (charCode > 0 || WT.isIE)\r\n"
  "    return true;\r\n"
  "  else {\r\n"
  "    if (WT.isOpera)\r\n"
  "      return (e.keyCode == 13 || e.keyCode == 27\r\n"
  "	      || (e.keyCode >= 32 && e.keyCode < 125));\r\n"
  "    else\r\n"
  "      return (e.keyCode == 13 || e.keyCode == 27 || e.keyCode == 32\r\n"
  "	      || (e.keyCode > 46 && e.keyCode < 112));\r\n"
  "\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "var repeatT = null, repeatI = null;\r\n"
  "\r\n"
  "this.isDblClick = function(o, e) {\r\n"
  "  if (o.wtClickTimeout &&\r\n"
  "      Math.abs(o.wtE1.clientX - e.clientX) < 3 &&\r\n"
  "      Math.abs(o.wtE1.clientY - e.clientY) < 3) {\r\n"
  "      clearTimeout(o.wtClickTimeout);\r\n"
  "      o.wtClickTimeout = null; o.wtE1 = null;\r\n"
  "      return true;\r\n"
  "  } else\r\n"
  "      return false;\r\n"
  "};\r\n"
  "\r\n"
  "this.eventRepeat = function(fun, startDelay, repeatInterval) {\r\n"
  "  WT.stopRepeat();\r\n"
  "\r\n"
  "  startDelay = startDelay || 500;\r\n"
  "  repeatInterval = repeatInterval || 50;\r\n"
  "\r\n"
  "  fun();\r\n"
  "\r\n"
  "  repeatT = setTimeout(function() {\r\n"
  "    repeatT = null;\r\n"
  "    fun();\r\n"
  "    repeatI = setInterval(fun, repeatInterval);\r\n"
  "  }, startDelay);\r\n"
  "};\r\n"
  "\r\n"
  "this.stopRepeat = function() {\r\n"
  "  if (repeatT) {\r\n"
  "    clearTimeout(repeatT);\r\n"
  "    repeatT = null;\r\n"
  "  }\r\n"
  "\r\n"
  "  if (repeatI) {\r\n"
  "    clearInterval(repeatI);\r\n"
  "    repeatI = null;\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "var cacheC = null, cacheS = null;\r\n"
  "\r\n"
  "this.css = function(c, s) {\r\n"
  "  if (c.style[s])\r\n"
  "    return c.style[s];\r\n"
  "  else {\r\n"
  "    if (c !== cacheC) {\r\n"
  "      cacheC = c;\r\n"
  "\r\n"
  "      if (window.getComputedStyle)\r\n"
  "	cacheS = window.getComputedStyle(c, null);\r\n"
  "      else if (c.currentStyle)\r\n"
  "	cacheS = c.currentStyle;\r\n"
  "      else\r\n"
  "	cacheS = null;\r\n"
  "    }\r\n"
  "\r\n"
  "    return cacheS ? cacheS[s] : null;\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "function parseCss(value, regex, defaultvalue) {\r\n"
  "  if (value == 'auto' || value == null)\r\n"
  "    return defaultvalue;\r\n"
  "  var m = regex.exec(value),\r\n"
  "      v = m && m.length == 2 ? m[1] : null;\r\n"
  "  return v ? parseFloat(v) : defaultvalue;\r\n"
  "}\r\n"
  "\r\n"
  "this.parsePx = function(v) {\r\n"
  "  return parseCss(v, /^\\s*(-?\\d+(?:\\.\\d+)?)\\s*px\\s*$/i, 0);\r\n"
  "};\r\n"
  "\r\n"
  "this.parsePct = function(v, defaultValue) {\r\n"
  "  return parseCss(v, /^\\s*(-?\\d+(?:\\.\\d+)?)\\s*\\%\\s*$/i, defaultValue);\r\n"
  "}\r\n"
  "\r\n"
  "// Get an element metric in pixels\r\n"
  "this.px = function(c, s) {\r\n"
  "  return WT.parsePx(WT.css(c, s));\r\n"
  "};\r\n"
  "\r\n"
  "// Get a widget style in pixels, when set directly\r\n"
  "this.pxself = function(c, s) {\r\n"
  "  return WT.parsePx(c.style[s]);\r\n"
  "};\r\n"
  "\r\n"
  "this.pctself = function(c, s) {\r\n"
  "  return WT.parsePct(c.style[s], 0);\r\n"
  "};\r\n"
  "\r\n"
  "// Convert from css property to element attribute (possibly a vendor name)\r\n"
  "this.styleAttribute = function(cssProp) {\r\n"
  "    function toCamelCase(str) {\r\n"
  "	var n=str.search(/-./);\r\n"
  "	while (n != -1) {\r\n"
  "	    var letter = (str.charAt(n+1)).toUpperCase();\r\n"
  "	    str = str.replace(/-./, letter);\r\n"
  "	    n=str.search(/-./);\r\n"
  "	}\r\n"
  "	return str;\r\n"
  "    }\r\n"
  "\r\n"
  "    var prefixes = ['', '-moz-', '-webkit-', '-o-', '-ms-'];\r\n"
  "    var elem = document.createElement('div'), i, il;\r\n"
  "\r\n"
  "    for (i = 0, il = prefixes.length; i < il; ++i) {\r\n"
  "	var attr = toCamelCase(prefixes[i] + cssProp);\r\n"
  "	if (attr in elem.style)\r\n"
  "	    return attr;\r\n"
  "    }\r\n"
  "    return toCamelCase(cssProp);\r\n"
  "};\r\n"
  "\r\n"
  "this.vendorPrefix = function(attr) {\r\n"
  "    var prefixes = ['Moz', 'Webkit', 'O', 'Ms'];\r\n"
  "    for (i = 0, il = prefixes.length; i < il; ++i) {\r\n"
  "	if (attr.search(prefixes[i]) != -1)\r\n"
  "	    return prefixes[i];\r\n"
  "    }\r\n"
  "    return '';\r\n"
  "};\r\n"
  "\r\n"
  "this.boxSizing = function(w) {\r\n"
  "  return (WT.css(w, WT.styleAttribute('box-sizing'))) === 'border-box';\r\n"
  "};\r\n"
  "\r\n"
  "// Return if an element (or one of its ancestors) is hidden\r\n"
  "this.isHidden = function(w) {\r\n"
  "  if (w.style.display == 'none' || $(w).hasClass('out'))\r\n"
  "    return true;\r\n"
  "  else {\r\n"
  "    w = w.parentNode;\r\n"
  "    if (w && !WT.hasTag(w, \"BODY\"))\r\n"
  "      return WT.isHidden(w);\r\n"
  "    else\r\n"
  "      return false;\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "this.innerWidth = function(el) {\r\n"
  "  var result = el.offsetWidth;\r\n"
  "  if (!WT.boxSizing(el)) {\r\n"
  "    result -= WT.px(el, 'paddingLeft') + WT.px(el, 'paddingRight')\r\n"
  "	  + WT.px(el, 'borderLeftWidth') + WT.px(el, 'borderRightWidth');\r\n"
  "  }\r\n"
  "  return result;\r\n"
  "};\r\n"
  "\r\n"
  "this.innerHeight = function(el) {\r\n"
  "  var result = el.offsetHeight;\r\n"
  "  if (!WT.boxSizing(el)) {\r\n"
  "    result -= WT.px(el, 'paddingTop') + WT.px(el, 'paddingBottom')\r\n"
  "	  + WT.px(el, 'borderTopWidth') + WT.px(el, 'borderBottomWidth');\r\n"
  "  }\r\n"
  "  return result;\r\n"
  "};\r\n"
  "\r\n"
  "this.IEwidth = function(c, min, max) {\r\n"
  "  if (c.parentNode) {\r\n"
  "    var r = c.parentNode.clientWidth\r\n"
  "    - WT.px(c, 'marginLeft')\r\n"
  "    - WT.px(c, 'marginRight')\r\n"
  "    - WT.px(c, 'borderLeftWidth')\r\n"
  "    - WT.px(c, 'borderRightWidth')\r\n"
  "    - WT.px(c.parentNode, 'paddingLeft')\r\n"
  "    - WT.px(c.parentNode, 'paddingRight');\r\n"
  "\r\n"
  "    min = WT.parsePct(min, 0);\r\n"
  "    max = WT.parsePct(max, 100000);\r\n"
  "\r\n"
  "    if (r < min)\r\n"
  "      return min-1;\r\n"
  "    else if (r > max)\r\n"
  "      return max+1;\r\n"
  "    else if (c.style[\"styleFloat\"] != \"\")\r\n"
  "      return min-1;\r\n"
  "    else\r\n"
  "      return \"auto\";\r\n"
  "  } else\r\n"
  "    return \"auto\";\r\n"
  "};\r\n"
  "\r\n"
  "this.hide = function(o) { WT.getElement(o).style.display = 'none'; };\r\n"
  "this.inline = function(o) { WT.getElement(o).style.display = 'inline'; };\r\n"
  "this.block = function(o) { WT.getElement(o).style.display = 'block'; };\r\n"
  "this.show = function(o, s) { WT.getElement(o).style.display = s; };\r\n"
  "\r\n"
  "var captureElement = null;\r\n"
  "this.firedTarget = null;\r\n"
  "\r\n"
  "this.target = function(event) {\r\n"
  "  try {\r\n"
  "    return WT.firedTarget || event.target || event.srcElement;\r\n"
  "  } catch (err) {\r\n"
  "    return null;\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "function delegateCapture(e) {\r\n"
  "  if (captureElement == null)\r\n"
  "    return null;\r\n"
  "\r\n"
  "  if (!e) e = window.event;\r\n"
  "\r\n"
  "  if (e) {\r\n"
  "    var t = WT.target(e), p = t;\r\n"
  "\r\n"
  "    while (p && p != captureElement)\r\n"
  "      p = p.parentNode;\r\n"
  "\r\n"
  "    /*\r\n"
  "     * We don't need to capture	the event when the event falls inside the\r\n"
  "     * capture element. In this way, more specific widgets inside may still\r\n"
  "     * handle (and cancel) the event if they want.\r\n"
  "     *\r\n"
  "     * On IE this means that we need to delegate the event to the event\r\n"
  "     * target; on other browsers we can just rely on event bubbling.\r\n"
  "     */\r\n"
  "    if (p == captureElement)\r\n"
  "      return WT.isIElt9 ? t : null;\r\n"
  "    else\r\n"
  "      return captureElement;\r\n"
  "  } else\r\n"
  "    return captureElement;\r\n"
  "}\r\n"
  "\r\n"
  "function mouseMove(e) {\r\n"
  "  var d = delegateCapture(e);\r\n"
  "\r\n"
  "  if (d && !delegating) {\r\n"
  "    if (!e) e = window.event;\r\n"
  "    delegating = true;\r\n"
  "    if (WT.isIElt9) {\r\n"
  "      WT.firedTarget = e.srcElement || d;\r\n"
  "      d.fireEvent('onmousemove', e);\r\n"
  "      WT.firedTarget = null;\r\n"
  "    } else\r\n"
  "      WT.condCall(d, 'onmousemove', e);\r\n"
  "    delegating = false;\r\n"
  "    return false;\r\n"
  "  } else\r\n"
  "    return true;\r\n"
  "}\r\n"
  "\r\n"
  "function mouseUp(e) {\r\n"
  "  var d = delegateCapture(e);\r\n"
  "  WT.capture(null);\r\n"
  "\r\n"
  "  if (d) {\r\n"
  "    if (!e) e = window.event;\r\n"
  "\r\n"
  "    if (WT.isIElt9) {\r\n"
  "      WT.firedTarget = e.srcElement || d;\r\n"
  "      d.fireEvent('onmouseup', e);\r\n"
  "      WT.firedTarget = null;\r\n"
  "    } else\r\n"
  "      WT.condCall(d, 'onmouseup', e);\r\n"
  "\r\n"
  "    WT.cancelEvent(e, WT.CancelPropagate);\r\n"
  "\r\n"
  "    return false;\r\n"
  "  } else\r\n"
  "    return true;\r\n"
  "}\r\n"
  "\r\n"
  "function touchMove(e) {\r\n"
  "  var d = delegateCapture(e);\r\n"
  "\r\n"
  "  if (d && !delegating) {\r\n"
  "    if (!e) e = window.event;\r\n"
  "    delegating = true;\r\n"
  "    if (WT.isIElt9) {\r\n"
  "      WT.firedTarget = e.srcElement || d;\r\n"
  "      d.fireEvent('ontouchmove', e);\r\n"
  "      WT.firedTarget = null;\r\n"
  "    } else\r\n"
  "      WT.condCall(d, 'ontouchmove', e);\r\n"
  "    delegating = false;\r\n"
  "    return false;\r\n"
  "  } else\r\n"
  "    return true;\r\n"
  "}\r\n"
  "\r\n"
  "function touchEnd(e) {\r\n"
  "  var d = delegateCapture(e);\r\n"
  "  WT.capture(null);\r\n"
  "\r\n"
  "  if (d) {\r\n"
  "    if (!e) e = window.event;\r\n"
  "\r\n"
  "    if (WT.isIElt9) {\r\n"
  "      WT.firedTarget = e.srcElement || d;\r\n"
  "      d.fireEvent('ontouchend', e);\r\n"
  "      WT.firedTarget = null;\r\n"
  "    } else\r\n"
  "      WT.condCall(d, 'ontouchend', e);\r\n"
  "\r\n"
  "    WT.cancelEvent(e, WT.CancelPropagate);\r\n"
  "\r\n"
  "    return false;\r\n"
  "  } else\r\n"
  "    return true;\r\n"
  "}\r\n"
  "var captureInitialized = false;\r\n"
  "\r\n"
  "function attachMouseHandlers(el) {\r\n"
  "  if (el.addEventListener) {\r\n"
  "    el.addEventListener('mousemove', mouseMove, true);\r\n"
  "    el.addEventListener('mouseup', mouseUp, true);\r\n"
  "\r\n"
  "    if (WT.isGecko) {\r\n"
  "      window.addEventListener('mouseout', function(e) {\r\n"
  "				if (!e.relatedTarget\r\n"
  "				    && WT.hasTag(e.target, \"HTML\"))\r\n"
  "				  mouseUp(e);\r\n"
  "			      }, true);\r\n"
  "    }\r\n"
  "  } else {\r\n"
  "    el.attachEvent('onmousemove', mouseMove);\r\n"
  "    el.attachEvent('onmouseup', mouseUp);\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "function attachTouchHandlers(el) {\r\n"
  "  if (el.addEventListener) {\r\n"
  "    el.addEventListener('touchmove', touchMove, true);\r\n"
  "    el.addEventListener('touchend', touchEnd, true);\r\n"
  "    //Gecko?\r\n"
  "  } else {\r\n"
  "    el.attachEvent('ontouchmove', touchMove);\r\n"
  "    el.attachEvent('ontouchend', touchEnd);\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "function initCapture() {\r\n"
  "  if (captureInitialized)\r\n"
  "    return;\r\n"
  "\r\n"
  "  captureInitialized = true;\r\n"
  "\r\n"
  "  var db = document.body;\r\n"
  "  attachMouseHandlers(db);\r\n"
  "  attachTouchHandlers(db);\r\n"
  "}\r\n"
  "\r\n"
  "this.capture = function(obj) {\r\n"
  "  initCapture();\r\n"
  "\r\n"
  "  if (captureElement && obj)\r\n"
  "    return;\r\n"
  "\r\n"
  "  // attach to possible iframes\r\n"
  "  for (var i=0; i < window.frames.length; i++)\r\n"
  "    try{\r\n"
  "      if (! window.frames[i].document.body.hasMouseHandlers) {\r\n"
  "        attachMouseHandlers(window.frames[i].document.body);\r\n"
  "        window.frames[i].document.body.hasMouseHandlers = true;\r\n"
  "      }\r\n"
  "    }catch (e) {\r\n"
  "    }\r\n"
  "\r\n"
  "  captureElement = obj;\r\n"
  "\r\n"
  "  var db = document.body;\r\n"
  "  if (!document.body.addEventListener)\r\n"
  "    if (obj != null)\r\n"
  "      db.setCapture();\r\n"
  "    else\r\n"
  "      db.releaseCapture();\r\n"
  "\r\n"
  "  if (obj != null) {\r\n"
  "    $(db).addClass('unselectable');\r\n"
  "    db.setAttribute('unselectable', 'on');\r\n"
  "    db.onselectstart = 'return false;';\r\n"
  "  } else {\r\n"
  "    $(db).removeClass('unselectable');\r\n"
  "    db.setAttribute('unselectable', 'off');\r\n"
  "    db.onselectstart = '';\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "this.checkReleaseCapture = function(obj, e) {\r\n"
  "  if (e && captureElement && (obj == captureElement) && (e.type == \"mouseup\" || e.type == \"touchend\"))\r\n"
  "    this.capture(null);\r\n"
  "};\r\n"
  "\r\n"
  "this.getElementsByClassName = function(className, parentElement) {\r\n"
  "  if (document.getElementsByClassName) {\r\n"
  "    return parentElement.getElementsByClassName(className);\r\n"
  "  } else {\r\n"
  "    var cc = parentElement.getElementsByTagName('*');\r\n"
  "    var els = [], c;\r\n"
  "    for (var i = 0, length = cc.length; i < length; i++) {\r\n"
  "      c = cc[i];\r\n"
  "      if (c.className.indexOf(className) != -1)\r\n"
  "	els.push(c);\r\n"
  "    }\r\n"
  "    return els;\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "/* Firefox, IE9 etc... */\r\n"
  "var inlineStyleSheet = null;\r\n"
  "\r\n"
  "function getInlineStyleSheet() {\r\n"
  "  if (!inlineStyleSheet) {\r\n"
  "    var i, il, ds = document.styleSheets;\r\n"
  "    for (i = 0, il = ds.length; i < il; ++i) {\r\n"
  "      var s = ds[i];\r\n"
  "      if (WT.hasTag(ds[i].ownerNode, 'STYLE')) {\r\n"
  "	inlineStyleSheet = s;\r\n"
  "	break;\r\n"
  "      }\r\n"
  "    }\r\n"
  "\r\n"
  "    if (!inlineStyleSheet) {\r\n"
  "      var s = document.createElement('style');\r\n"
  "      document.getElementsByTagName('head')[0].appendChild(s);\r\n"
  "\r\n"
  "      inlineStyleSheet = s.sheet;\r\n"
  "    }\r\n"
  "  }\r\n"
  "\r\n"
  "  return inlineStyleSheet;\r\n"
  "}\r\n"
  "\r\n"
  "this.addCss = function(selector, style) {\r\n"
  "  var s = getInlineStyleSheet();\r\n"
  "\r\n"
  "  // strange error with IE9 when in iframe\r\n"
  "  var pos = s.cssRules ? s.cssRules.length : 0;\r\n"
  "  s.insertRule(selector + ' { ' + style + ' }', pos);\r\n"
  "};\r\n"
  "\r\n"
  "/* IE<9 & Konqueror */\r\n"
  "this.addCssText = function(cssText) {\r\n"
  "  var s = document.getElementById('Wt-inline-css');\r\n"
  "\r\n"
  "  if (!s) {\r\n"
  "    s = document.createElement('style');\r\n"
  "    s.id = 'Wt-inline-css';\r\n"
  "    document.getElementsByTagName('head')[0].appendChild(s);\r\n"
  "  }\r\n"
  "\r\n"
  "  if (!s.styleSheet) { // Konqueror\r\n"
  "    var t = document.createTextNode(cssText);\r\n"
  "    s.appendChild(t);\r\n"
  "  } else {\r\n"
  "    var ss = s.previousSibling;\r\n"
  "    if (!ss\r\n"
  "	|| !WT.hasTag(ss, \"STYLE\")\r\n"
  "	|| ss.styleSheet.cssText.length > 32*1024) {\r\n"
  "      ss = document.createElement('style');\r\n"
  "      s.parentNode.insertBefore(ss, s);\r\n"
  "      ss.styleSheet.cssText = cssText;\r\n"
  "    } else {\r\n"
  "      ss.styleSheet.cssText += cssText;\r\n"
  "    }\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "// from: http://www.hunlock.com/blogs/Totally_Pwn_CSS_with_Javascript\r\n"
  "this.getCssRule = function(selector, deleteFlag) {\r\n"
  "  selector = selector.toLowerCase();\r\n"
  "\r\n"
  "  if (document.styleSheets) {\r\n"
  "    for (var i=0; i<document.styleSheets.length; i++) {\r\n"
  "      var styleSheet = document.styleSheets[i];\r\n"
  "      var ii = 0;\r\n"
  "      var cssRule;\r\n"
  "      do {\r\n"
  "	cssRule = null;\r\n"
  "	try {\r\n"
  "	  if (styleSheet.cssRules)\r\n"
  "	    cssRule = styleSheet.cssRules[ii];\r\n"
  "	  else if (styleSheet.rules)\r\n"
  "	    cssRule = styleSheet.rules[ii];\r\n"
  "	  if (cssRule && cssRule.selectorText) {\r\n"
  "	    if (cssRule.selectorText.toLowerCase()==selector) {\r\n"
  "	      if (deleteFlag == 'delete') {\r\n"
  "		if (styleSheet.cssRules)\r\n"
  "		  styleSheet.deleteRule(ii);\r\n"
  "		else\r\n"
  "		  styleSheet.removeRule(ii);\r\n"
  "		return true;\r\n"
  "	      } else\r\n"
  "		return cssRule;\r\n"
  "	    }\r\n"
  "	  }\r\n"
  "	} catch (err) {\r\n"
  "	  /*\r\n"
  "	     firefox security error 1000 when access a stylesheet.cssRules\r\n"
  "	     hosted from another domain\r\n"
  "	   */\r\n"
  "	}\r\n"
  "\r\n"
  "	++ii;\r\n"
  "      } while (cssRule);\r\n"
  "    }\r\n"
  "  }\r\n"
  "\r\n"
  "  return false;\r\n"
  "};\r\n"
  "\r\n"
  "this.removeCssRule = function(selector) {\r\n"
  "  return WT.getCssRule(selector, 'delete');\r\n"
  "};\r\n"
  "\r\n"
  "this.addStyleSheet = function(uri, media) {\r\n"
  "  if (document.createStyleSheet) {\r\n"
  "    setTimeout(function() { document.createStyleSheet(uri); }, 15);\r\n"
  "  } else {\r\n"
  "    var s = document.createElement('link');\r\n"
  "    s.setAttribute('href', uri);\r\n"
  "    s.setAttribute('type','text/css');\r\n"
  "    s.setAttribute('rel','stylesheet');\r\n"
  "    if (media != '' && media != 'all')\r\n"
  "      s.setAttribute('media', media);\r\n"
  "    var ll = document.getElementsByTagName('link');\r\n"
  "    if (ll.length > 0) {\r\n"
  "      var l = ll[ll.length - 1];\r\n"
  "      l.parentNode.insertBefore(s, l.nextSibling);\r\n"
  "    } else {\r\n"
  "      document.body.appendChild(s);\r\n"
  "    }\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "this.removeStyleSheet = function(uri) {\r\n"
  "  if ($('link[rel=stylesheet][href~=\"' + uri + '\"]'))\r\n"
  "    $('link[rel=stylesheet][href~=\"' + uri + '\"]').remove();\r\n"
  "  var sheets = document.styleSheets;\r\n"
  "  for (var i=0; i<sheets.length; ++i) {\r\n"
  "    var sheet = sheets[i];\r\n"
  "    j = 0;\r\n"
  "    if (sheet) {\r\n"
  "      var rule = null;\r\n"
  "      do {\r\n"
  "        try {\r\n"
  "          if (sheet.cssRules)\r\n"
  "            rule = sheet.cssRules[j]; // firefox\r\n"
  "          else\r\n"
  "            rule = sheet.rules[j];    // IE\r\n"
  "\r\n"
  "          if (rule && rule.cssText ===\r\n"
  "              \"@import url(\\\"\" + uri +  \"\\\");\") {\r\n"
  "            if (sheet.cssRules)\r\n"
  "              sheet.deleteRule(j);// firfox\r\n"
  "            else\r\n"
  "              sheet.removeRule(j);//IE\r\n"
  "            break; // only remove 1 rule !!!!\r\n"
  "          }\r\n"
  "        } catch (err) {\r\n"
  "          /*\r\n"
  "        * firefox security error 1000 when access a stylesheet.cssRules\r\n"
  "        * hosted from another domain\r\n"
  "        */\r\n"
  "        }\r\n"
  "        ++j;\r\n"
  "      } while(rule)\r\n"
  "    }\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "this.windowSize = function() {\r\n"
  "  var x, y;\r\n"
  "\r\n"
  "  if (typeof (window.innerWidth) === 'number') {\r\n"
  "    x = window.innerWidth;\r\n"
  "    y = window.innerHeight;\r\n"
  "  } else {\r\n"
  "    x = document.documentElement.clientWidth;\r\n"
  "    y = document.documentElement.clientHeight;\r\n"
  "  }\r\n"
  "\r\n"
  "  return { x: x, y: y};\r\n"
  "};\r\n"
  "\r\n"
  "/*\r\n"
  " * position right to (x) or left from (rightx) and\r\n"
  " * bottom of (y) or top from (bottomy)\r\n"
  " */\r\n"
  "this.fitToWindow = function(e, x, y, rightx, bottomy) {\r\n"
  "  var hsides = [ 'left', 'right' ],\r\n"
  "      vsides = [ 'top', 'bottom' ];\r\n"
  "\r\n"
  "  e.style[hsides[0]] = e.style[hsides[1]] = 'auto';\r\n"
  "  e.style[vsides[0]] = e.style[vsides[1]] = 'auto';\r\n"
  "\r\n"
  "  var reserveWidth = e.offsetWidth,\r\n"
  "      reserveHeight = e.offsetHeight,\r\n"
  "      hside, vside,\r\n"
  "      windowSize = WT.windowSize(),\r\n"
  "      windowX = document.body.scrollLeft + document.documentElement.scrollLeft,\r\n"
  "      windowY = document.body.scrollTop + document.documentElement.scrollTop;\r\n"
  "\r\n"
  "    /*\r\n"
  "     * Should really distinguish between static versus dynamic: for a\r\n"
  "     * widget that can grow dynamically (e.g. a suggestion popup) we\r\n"
  "     * should prepare ourselves and consider maximum size here\r\n"
  "     */\r\n"
  "  if (!$(e).hasClass('Wt-tooltip')) {\r\n"
  "    reserveWidth = WT.px(e, 'maxWidth') || reserveWidth;\r\n"
  "    reserveHeight = WT.px(e, 'maxHeight') || reserveHeight;\r\n"
  "  }\r\n"
  "\r\n"
  "  var op = e.offsetParent;\r\n"
  "  if (!op)\r\n"
  "    return;\r\n"
  "\r\n"
  "  var offsetParent = WT.widgetPageCoordinates(op);\r\n"
  "\r\n"
  "  if (reserveWidth > windowSize.x) {\r\n"
  "    // wider than window\r\n"
  "    x = windowX;\r\n"
  "    hside = 0;\r\n"
  "  } else if (x + reserveWidth > windowX + windowSize.x) {\r\n"
  "    // too far right, chose other side\r\n"
  "    var scrollX = op.scrollLeft;\r\n"
  "    if (op == document.body)\r\n"
  "      scrollX = (op.clientWidth - windowSize.x);\r\n"
  "    rightx = rightx - offsetParent.x + scrollX;\r\n"
  "    x = op.clientWidth - (rightx + WT.px(e, 'marginRight'));\r\n"
  "    hside = 1;\r\n"
  "  } else {\r\n"
  "    var scrollX = op.scrollLeft;\r\n"
  "    if (op == document.body)\r\n"
  "      scrollX = 0;\r\n"
  "    x = x - offsetParent.x + scrollX;\r\n"
  "    x = x - WT.px(e, 'marginLeft');\r\n"
  "    hside = 0;\r\n"
  "  }\r\n"
  "\r\n"
  "  if (reserveHeight > windowSize.y) {\r\n"
  "    // taller than window\r\n"
  "    y = windowY;\r\n"
  "    vside = 0;\r\n"
  "  } else if (y + reserveHeight > windowY + windowSize.y) {\r\n"
  "    // too far below, chose other side\r\n"
  "    if (bottomy > windowY + windowSize.y)\r\n"
  "      bottomy = windowY + windowSize.y;\r\n"
  "    var scrollY = op.scrollTop;\r\n"
  "    if (op == document.body)\r\n"
  "      scrollY = (op.clientHeight - windowSize.y);\r\n"
  "    bottomy = bottomy - offsetParent.y + scrollY;\r\n"
  "    y = op.clientHeight - \r\n"
  "	  (bottomy + WT.px(e, 'marginBottom') + WT.px(e, 'borderBottomWidth'));\r\n"
  "    vside = 1;\r\n"
  "  } else {\r\n"
  "    var scrollY = op.scrollTop;\r\n"
  "    if (op == document.body)\r\n"
  "      scrollY = 0;\r\n"
  "    y = y - offsetParent.y + scrollY;\r\n"
  "    y = y - WT.px(e, 'marginTop') + WT.px(e, 'borderTopWidth');\r\n"
  "    vside = 0;\r\n"
  "  }\r\n"
  "\r\n"
  "  /*\r\n"
  "  if (x < wx)\r\n"
  "    x = wx + ws.x - e.offsetWidth - 3;\r\n"
  "  if (y < wy)\r\n"
  "    y = wy + ws.y - e.offsetHeight - 3;\r\n"
  "  */\r\n"
  "\r\n"
  "  e.style[hsides[hside]] = x + 'px';\r\n"
  "  e.style[vsides[vside]] = y + 'px';\r\n"
  "};\r\n"
  "\r\n"
  "this.positionXY = function(id, x, y) {\r\n"
  "  var w = WT.getElement(id);\r\n"
  "\r\n"
  "  if (!WT.isHidden(w)) {\r\n"
  "    w.style.display = 'block';\r\n"
  "    WT.fitToWindow(w, x, y, x, y);\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "this.Horizontal = 0x1;\r\n"
  "this.Vertical = 0x2;\r\n"
  "\r\n"
  "this.positionAtWidget = function(id, atId, orientation, delta) {\r\n"
  "  var w = WT.getElement(id),\r\n"
  "    atw = WT.getElement(atId);\r\n"
  "\r\n"
  "  if (!delta)\r\n"
  "    delta = 0;\r\n"
  "\r\n"
  "  if (!atw || !w)\r\n"
  "    return;\r\n"
  "\r\n"
  "  var xy = WT.widgetPageCoordinates(atw),\r\n"
  "    x, y, rightx, bottomy;\r\n"
  "\r\n"
  "  w.style.position = 'absolute';\r\n"
  "  if (WT.css(w, 'display') == 'none')\r\n"
  "    w.style.display = 'block';\r\n"
  "\r\n"
  "  if (orientation === WT.Horizontal) {\r\n"
  "    x = xy.x + atw.offsetWidth;\r\n"
  "    y = xy.y + delta;\r\n"
  "    rightx = xy.x;\r\n"
  "    bottomy = xy.y + atw.offsetHeight - delta;\r\n"
  "  } else {\r\n"
  "    x = xy.x;\r\n"
  "    y = xy.y + atw.offsetHeight;\r\n"
  "    rightx = xy.x + atw.offsetWidth;\r\n"
  "    bottomy = xy.y;\r\n"
  "  }\r\n"
  "\r\n"
  "  /*\r\n"
  "   * Reparent the widget in a suitable parent:\r\n"
  "   *  an ancestor of w which isn't overflowing\r\n"
  "   */\r\n"
  "  var p, pp = atw;\r\n"
  "  w.parentNode.removeChild(w);\r\n"
  "\r\n"
  "  for (p = pp.parentNode; !p.classList.contains('Wt-domRoot'); p = p.parentNode) {\r\n"
  "    if (p.wtReparentBarrier) {\r\n"
  "      break;\r\n"
  "    }\r\n"
  "\r\n"
  "    // e.g. a layout widget has clientHeight=0 since it's relative\r\n"
  "    // with only absolutely positioned children. We are a bit more liberal\r\n"
  "    // here to catch other simular situations, and 100px seems like space\r\n"
  "    // needed anyway?\r\n"
  "    //\r\n"
  "    // We need to check whether overflowX or overflowY is not visible, because\r\n"
  "    // of an issue on Firefox where clientWidth !== scrollWidth and\r\n"
  "    // clientHeight !== scrollHeight when using the border-collapse CSS property.\r\n"
  "    if (WT.css(p, 'display') != 'inline' &&\r\n"
  "        p.clientHeight > 100 &&\r\n"
  "        (getComputedStyle(p).overflowY === 'scroll' ||\r\n"
  "         getComputedStyle(p).overflowX === 'scroll' ||\r\n"
  "         (p.scrollHeight > p.clientHeight && getComputedStyle(p).overflowY === 'auto') ||\r\n"
  "         (p.scrollWidth > p.clientWidth && getComputedStyle(p).overflowX === 'auto'))) {\r\n"
  "      break;\r\n"
  "    }\r\n"
  "\r\n"
  "    pp = p;\r\n"
  "  }\r\n"
  "\r\n"
  "  var posP = WT.css(p, 'position');\r\n"
  "  if (posP != 'absolute' && posP != 'relative')\r\n"
  "    p.style.position = 'relative';\r\n"
  "  \r\n"
  "  p.appendChild(w);\r\n"
  "  $(w).addClass('wt-reparented');\r\n"
  "\r\n"
  "  WT.fitToWindow(w, x, y, rightx, bottomy);\r\n"
  "\r\n"
  "  w.style.visibility='';\r\n"
  "};\r\n"
  "\r\n"
  "this.hasFocus = function(el) {\r\n"
  "  try {\r\n"
  "    return el === document.activeElement;\r\n"
  "  } catch(e) {\r\n"
  "    return false;\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "this.progressed = function(domRoot) {\r\n"
  "  var doc = document, db = doc.body;\r\n"
  "  var form = this.getElement('Wt-form');\r\n"
  "\r\n"
  "  domRoot.style.display = form.style.display;\r\n"
  "  form.parentNode.replaceChild(domRoot, form);\r\n"
  "\r\n"
  "  if (db.removeEventListener)\r\n"
  "    db.removeEventListener('click', delayClick, true);\r\n"
  "  else\r\n"
  "    db.detachEvent('click', delayClick);\r\n"
  "\r\n"
  "  setTimeout(function() {\r\n"
  "      var i, il;\r\n"
  "      for (i = 0, il = delayedClicks.length; i < il; ++i) {\r\n"
  "	if (doc.createEvent) {\r\n"
  "	  var e = delayedClicks[i];\r\n"
  "	  var ec = doc.createEvent('MouseEvents');\r\n"
  "	  ec.initMouseEvent('click', e.bubbles, e.cancelable, window,\r\n"
  "			    e.detail, e.screenX, e.screenY,\r\n"
  "			    e.clientX, e.clientY, e.ctrlKey, e.altKey,\r\n"
  "			    e.shiftKey, e.metaKey, e.button, null);\r\n"
  "	  var el = WT.getElement(e.targetId);\r\n"
  "	  if (el)\r\n"
  "	    el.dispatchEvent(ec);\r\n"
  "	} else {\r\n"
  "	  var e = delayedClicks[i];\r\n"
  "	  var ec = doc.createEventObject();\r\n"
  "	  for (i in e)\r\n"
  "	    ec[i] = e[i];\r\n"
  "	  var el = WT.getElement(e.targetId);\r\n"
  "	  if (el)\r\n"
  "	    el.fireEvent('onclick', ec);\r\n"
  "	}\r\n"
  "      }\r\n"
  "    }, 0);\r\n"
  "};\r\n"
  "\r\n"
  "var html5History = !!(window.history && window.history.pushState);\r\n"
  "\r\n"
  "/*\r\n"
  " * A less aggressive URL encoding than encodeURIComponent which does\r\n"
  " * for example not encode '/'\r\n"
  " */\r\n"
  "function gentleURIEncode(s) {\r\n"
  "  return s.replace(/%/g, '%25')\r\n"
  "    .replace(/\\+/g, '%2b')\r\n"
  "    .replace(/ /g, '%20')\r\n"
  "    //.replace(/#/g, '%23')\r\n"
  "    .replace(/&/g, '%26');\r\n"
  "}\r\n"
  "\r\n"
  "if (html5History) {\r\n"
  "  // we need to update the scroll position at the scroll event,\r\n"
  "  // because we don't have the chance to update the html5history\r\n"
  "  // state anymore at the moment that onPopState() is called.\r\n"
  "  // For navigation, when pushState() is called, the scroll\r\n"
  "  // history can be updated before the pushState() call.\r\n"
  "\r\n"
  "  // delayCallback: delay the calling of the callback by delay\r\n"
  "  //\r\n"
  "  // as long as events keep coming in, we delay it further, so\r\n"
  "  // the callback will only run \"delay\" ms after the last invocation.\r\n"
  "  function delayCallback(callback, delay) {\r\n"
  "    var timer = null;\r\n"
  "    var args = null;\r\n"
  "\r\n"
  "    function dispatch()\r\n"
  "    {\r\n"
  "      callback.apply(null, args);\r\n"
  "      timer = null;\r\n"
  "      args = null;\r\n"
  "    }\r\n"
  "\r\n"
  "    function proxy() {\r\n"
  "      args = arguments;\r\n"
  "\r\n"
  "      if (timer) {\r\n"
  "        clearTimeout(timer);\r\n"
  "        timer = null;\r\n"
  "      }\r\n"
  "      timer = setTimeout(dispatch, delay);\r\n"
  "    }\r\n"
  "\r\n"
  "    return proxy;\r\n"
  "  }\r\n"
  "\r\n"
  "  function updateScrollHistory() {\r\n"
  "    //console.log(\"updateScrollHistory\");\r\n"
  "    try {\r\n"
  "      var newState = window.history.state;\r\n"
  "      if (window.history.state == null) {\r\n"
  "        // freshly initiated session, no state present yet\r\n"
  "        newState = {};\r\n"
  "        newState.state = \"\";\r\n"
  "        newState.title = window.document.title;\r\n"
  "      }\r\n"
  "      newState.pageXOffset = window.pageXOffset;\r\n"
  "      newState.pageYOffset = window.pageYOffset;\r\n"
  "      window.history.replaceState(newState, newState.title);\r\n"
  "    } catch (error) {\r\n"
  "      // shouldn't happen\r\n"
  "      console.log(error.toString());\r\n"
  "    }\r\n"
  "  }\r\n"
  "  window.addEventListener('scroll', delayCallback(updateScrollHistory, 100));\r\n"
  "\r\n"
  "  // the 'auto' scrollRestoration gives too much flicker, since it\r\n"
  "  // updates the scroll state before the page is updated\r\n"
  "  // Browsers not supporting manual scrollRestoration, the flicker\r\n"
  "  // should not be worse than what it was.\r\n"
  "  window.history.scrollRestoration = 'manual';\r\n"
  "\r\n"
  "  this.history = (function()\r\n"
  "{\r\n"
  "  var currentState = null, baseUrl = null, ugly = false, cb = null,\r\n"
  "      stateMap = { }, w = window;\r\n"
  "\r\n"
  "  function saveState(state) {\r\n"
  "    stateMap[w.location.pathname + w.location.search] = state;\r\n"
  "  }\r\n"
  "\r\n"
  "  return {\r\n"
  "    _initialize: function() { },\r\n"
  "\r\n"
  "    _initTimeout: function() { },\r\n"
  "\r\n"
  "    register: function (initialState, onStateChange) {\r\n"
  "      currentState = initialState;\r\n"
  "      cb = onStateChange;\r\n"
  "      saveState(initialState);\r\n"
  "\r\n"
  "      function onPopState(event) {\r\n"
  "	var newState = null;\r\n"
  "        if (event.state && event.state.state)\r\n"
  "          newState = event.state.state;\r\n"
  "\r\n"
  "	if (newState == null)\r\n"
  "	  newState = stateMap[w.location.pathname + w.location.search];\r\n"
  "\r\n"
  "	if (newState == null) {\r\n"
  "	  var endw = w.location.pathname.lastIndexOf(currentState);\r\n"
  "	  if (endw != -1 &&\r\n"
  "	      endw == w.location.pathname.length - currentState.length) {\r\n"
  "	    saveState(currentState);\r\n"
  "	    return;\r\n"
  "	  } else {\r\n"
  "	    newState = w.location.pathname.substr(baseUrl.length);\r\n"
  "	  }\r\n"
  "	}\r\n"
  "\r\n"
  "	if (newState != currentState) {\r\n"
  "	  currentState = newState;\r\n"
  "	  onStateChange(currentState != \"\" ? currentState : \"/\");\r\n"
  "	}\r\n"
  "        //console.log(\"onPopState: \" + JSON.stringify(window.history.state));\r\n"
  "      }\r\n"
  "\r\n"
  "      w.addEventListener(\"popstate\", onPopState, false);\r\n"
  "    },\r\n"
  "\r\n"
  "    initialize: function (stateField, histFrame, deployUrl) {\r\n"
  "      WT.resolveRelativeAnchors();\r\n"
  "\r\n"
  "      baseUrl = deployUrl;\r\n"
  "      if (baseUrl.length >= 1 && baseUrl[baseUrl.length - 1] == '/') {\r\n"
  "_$_$if_UGLY_INTERNAL_PATHS_$_();\r\n"
  "	ugly = true;\r\n"
  "_$_$endif_$_();\r\n"
  "_$_$ifnot_UGLY_INTERNAL_PATHS_$_();\r\n"
  "	baseUrl = baseUrl.substr(0, baseUrl.length - 1);\r\n"
  "_$_$endif_$_();\r\n"
  "      }\r\n"
  "    },\r\n"
  "\r\n"
  "    navigate: function (state, generateEvent) {\r\n"
  "      //console.log(\"navigate: \" + state);\r\n"
  "      WT.resolveRelativeAnchors();\r\n"
  "\r\n"
  "      currentState = state;\r\n"
  "\r\n"
  "      var ip = gentleURIEncode(state), url = baseUrl;\r\n"
  "\r\n"
  "      if (ip.length != 0)\r\n"
  "	url += (ugly ? \"?_=\" : \"\") + ip;\r\n"
  "\r\n"
  "      if (!ugly) {\r\n"
  "	url += window.location.search;\r\n"
  "      } else {\r\n"
  "	function stripHashParameter(q) {\r\n"
  "	  if (q.length > 1)\r\n"
  "	    q = q.substr(1);\r\n"
  "\r\n"
  "	  var qp = q.split(\"&\"), i, il;\r\n"
  "	  q = \"\";\r\n"
  "\r\n"
  "	  for (i=0, il = qp.length; i<il; ++i)\r\n"
  "	    if (qp[i].split(\"=\")[0] != '_')\r\n"
  "	      q += (q.length ? '&' : '?') + qp[i];\r\n"
  "\r\n"
  "	  return q;\r\n"
  "	}\r\n"
  "\r\n"
  "	var q = stripHashParameter(window.location.search);\r\n"
  "\r\n"
  "	if (q.length > 1) {\r\n"
  "	  if (q.length > 2 && q[0] == '?' && q[1] == '&')\r\n"
  "	    q = q.substr(1);\r\n"
  "	  if (url.indexOf('?') == -1)\r\n"
  "	    url += '?' + q.substr(1);\r\n"
  "	  else\r\n"
  "	    url += '&' + q.substr(1);\r\n"
  "	}\r\n"
  "      }\r\n"
  "\r\n"
  "      try {\r\n"
  "        var historyState = { };\r\n"
  "        historyState.state = state ? state : \"\";\r\n"
  "        // By not setting historyState.page[XY]Offset, we indicate that\r\n"
  "        // this state change was made by navigation rather than by\r\n"
  "        // the back/forward button\r\n"
  "        // keep title for call to replaceState when page offset is updated\r\n"
  "        historyState.title = document.title;\r\n"
  "        // update scroll position of stack top with the position at the time of leaving the page\r\n"
  "        updateScrollHistory();\r\n"
  "        //console.log(\"pushState before: \" + JSON.stringify(window.history.state));\r\n"
  "	window.history.pushState(historyState, document.title, url);\r\n"
  "        //console.log(\"pushState after: \" + JSON.stringify(window.history.state));\r\n"
  "      } catch (error) {\r\n"
  "	/*\r\n"
  "	 * In case we are wrong about our baseUrl or base href\r\n"
  "	 * In any case, this shouldn't be fatal.\r\n"
  "	 */\r\n"
  "	console.log(error.toString());\r\n"
  "      }\r\n"
  "\r\n"
  "      // We used to call scrollIntoView here. We modified this to have\r\n"
  "      // scrollIntoView called after the server round-trip, so that the\r\n"
  "      // new content is certainly visible before we scroll. This avoids\r\n"
  "      // flicker. If the rendering result was pre-learned client-side,\r\n"
  "      // the page will scroll to the right position only after a server\r\n"
  "      // round-trip, which is not ideal.\r\n"
  "\r\n"
  "      if (generateEvent)\r\n"
  "	cb(state);\r\n"
  "    },\r\n"
  "\r\n"
  "    getCurrentState: function () {\r\n"
  "      return currentState;\r\n"
  "    }\r\n"
  "  };\r\n"
  "})();\r\n"
  "} else if (WT.isIE8) {\r\n"
  "  this.history = (function()\r\n"
  "{\r\n"
  "  var currentState = null, cb = null, w = window;\r\n"
  "\r\n"
  "  return {\r\n"
  "    _initialize: function() { },\r\n"
  "\r\n"
  "    _initTimeout: function() { },\r\n"
  "\r\n"
  "    register: function (initialState, onStateChange) {\r\n"
  "      currentState = initialState;\r\n"
  "      cb = onStateChange;\r\n"
  "\r\n"
  "      function onHashChange() {\r\n"
  "	if (currentState != w.location.hash) {\r\n"
  "	  currentState = w.location.hash.substring(1);\r\n"
  "	  cb(currentState);\r\n"
  "	}\r\n"
  "      }\r\n"
  "\r\n"
  "      w.onhashchange = onHashChange;\r\n"
  "    },\r\n"
  "\r\n"
  "    initialize: function (stateField, histFrame, deployUrl) {\r\n"
  "    },\r\n"
  "\r\n"
  "    navigate: function (state, generateEvent) {\r\n"
  "      currentState = state;\r\n"
  "\r\n"
  "      w.location.hash = state;\r\n"
  "\r\n"
  "      if (generateEvent)\r\n"
  "	cb(state);\r\n"
  "    },\r\n"
  "\r\n"
  "    getCurrentState: function () {\r\n"
  "      return currentState;\r\n"
  "    }\r\n"
  "  };\r\n"
  "})();\r\n"
  "} else {\r\n"
  "  this.history = (function()\r\n"
  "{\r\n"
  "  /**\r\n"
  "   * @preserve\r\n"
  "   * Includes Yahoo History Frameowork\r\n"
  "   * Copyright (c) 2008, Yahoo! Inc. All rights reserved.\r\n"
  "   * Code licensed under the BSD License:\r\n"
  "   * http://developer.yahoo.net/yui/license.txt\r\n"
  "   * version: 2.5.2\r\n"
  "   */\r\n"
  "  var _UAie = WT.isIElt9;\r\n"
  "  var _UAopera = false;\r\n"
  "  var _onLoadFn = null;\r\n"
  "  var _histFrame = null;\r\n"
  "  var _stateField = null;\r\n"
  "  var _initialized = false;\r\n"
  "  var _interval = null;\r\n"
  "  var _fqstates = [];\r\n"
  "  var _initialState, _currentState;\r\n"
  "  var _onStateChange = [];\r\n"
  "  function _getHash() {\r\n"
  "    var i, href;\r\n"
  "    href = location.href;\r\n"
  "    i = href.indexOf(\"#\");\r\n"
  "    return i >= 0 ? href.substr(i + 1) : null;\r\n"
  "  }\r\n"
  "  function _storeStates() {\r\n"
  "    _stateField.value = _initialState + \"|\" + _currentState;\r\n"
  "  }\r\n"
  "  function onStateChange() {\r\n"
  "    var i, il;\r\n"
  "    for (i = 0, il = _onStateChange.length; i < il; ++i) {\r\n"
  "      _onStateChange[i](unescape(_currentState));\r\n"
  "    }\r\n"
  "  }\r\n"
  "  function _handle";
  const char * Wt_js2 = "FQStateChange(fqstate) {\r\n"
  "    var currentState;\r\n"
  "    if (!fqstate) {\r\n"
  "      _currentState = _initialState;\r\n"
  "      onStateChange();\r\n"
  "      return;\r\n"
  "    }\r\n"
  "    currentState = fqstate;\r\n"
  "    if (!currentState || _currentState !== currentState) {\r\n"
  "      _currentState = currentState || _initialState;\r\n"
  "      onStateChange();\r\n"
  "    }\r\n"
  "  }\r\n"
  "  function _updateIFrame (fqstate) {\r\n"
  "    var html, doc;\r\n"
  "    html = '<html><body><div id=\"state\">' + fqstate\r\n"
  "      + '</div></body></html>';\r\n"
  "    try {\r\n"
  "      doc = _histFrame.contentWindow.document;\r\n"
  "      doc.open();\r\n"
  "      doc.write(html);\r\n"
  "      doc.close();\r\n"
  "      return true;\r\n"
  "    } catch (e) {\r\n"
  "      return false;\r\n"
  "    }\r\n"
  "  }\r\n"
  "  function _checkIframeLoaded() {\r\n"
  "    var doc, elem, fqstate, hash;\r\n"
  "    if (!_histFrame.contentWindow || !_histFrame.contentWindow.document) {\r\n"
  "      setTimeout(_checkIframeLoaded, 10);\r\n"
  "      return;\r\n"
  "    }\r\n"
  "    doc = _histFrame.contentWindow.document;\r\n"
  "    elem = doc.getElementById(\"state\");\r\n"
  "    fqstate = elem ? elem.innerText : null;\r\n"
  "    hash = _getHash();\r\n"
  "    setInterval(function () {\r\n"
  "	var newfqstate, newHash;\r\n"
  "	doc = _histFrame.contentWindow.document;\r\n"
  "	elem = doc.getElementById(\"state\");\r\n"
  "	newfqstate = elem ? elem.innerText : null;\r\n"
  "	newHash = _getHash();\r\n"
  "	if (newfqstate !== fqstate) {\r\n"
  "	  fqstate = newfqstate;\r\n"
  "	  _handleFQStateChange(fqstate);\r\n"
  "	  if (!fqstate) {\r\n"
  "	    newHash = _initialState;\r\n"
  "	  } else {\r\n"
  "	    newHash = fqstate;\r\n"
  "	  }\r\n"
  "	  if (location.hash != newHash && \r\n"
  "	      location.hash.substring(1) != newHash)\r\n"
  "	    location.hash = newHash;\r\n"
  "	  hash = newHash;\r\n"
  "	  _storeStates();\r\n"
  "	} else if (newHash !== hash) {\r\n"
  "	  hash = newHash;\r\n"
  "	  _updateIFrame(newHash);\r\n"
  "	}\r\n"
  "      }, 50);\r\n"
  "    _initialized = true;\r\n"
  "    if (_onLoadFn != null)\r\n"
  "      _onLoadFn();\r\n"
  "  }\r\n"
  "\r\n"
  "  function _initTimeout() {\r\n"
  "    if (_UAie)\r\n"
  "      return;\r\n"
  "\r\n"
  "    var hash = _getHash(), counter = history.length;\r\n"
  "\r\n"
  "    if (_interval)\r\n"
  "      clearInterval(_interval);\r\n"
  "    _interval = setInterval(function () {\r\n"
  "	var state, newHash, newCounter;\r\n"
  "	newHash = _getHash();\r\n"
  "	newCounter = history.length;\r\n"
  "	if (newHash !== hash) {\r\n"
  "	  hash = newHash;\r\n"
  "	  counter = newCounter;\r\n"
  "	  _handleFQStateChange(hash);\r\n"
  "	  _storeStates();\r\n"
  "	}\r\n"
  "      }, 50);\r\n"
  "  }\r\n"
  "\r\n"
  "  function _initialize() {\r\n"
  "    var parts;\r\n"
  "    parts = _stateField.value.split(\"|\");\r\n"
  "    if (parts.length > 1) {\r\n"
  "      _initialState = parts[0];\r\n"
  "      _currentState = parts[1];\r\n"
  "    } else\r\n"
  "      _initialState = _currentState = \"\";\r\n"
  "\r\n"
  "    if (parts.length > 2) {\r\n"
  "      _fqstates = parts[2].split(\",\");\r\n"
  "    }\r\n"
  "    if (_UAie) {\r\n"
  "      _checkIframeLoaded();\r\n"
  "    } else {\r\n"
  "      _initTimeout();\r\n"
  "      _initialized = true;\r\n"
  "      if (_onLoadFn != null)\r\n"
  "	_onLoadFn();\r\n"
  "    }\r\n"
  "  }\r\n"
  "  return {\r\n"
  "  _initialize: function() {\r\n"
  "    if (_stateField != null)\r\n"
  "      _initialize();\r\n"
  "  },\r\n"
  "  _initTimeout: function() {\r\n"
  "      _initTimeout();\r\n"
  "  },\r\n"
  "  register: function (initialState, onStateChange) {\r\n"
  "    if (!_initialized) {\r\n"
  "      _initialState = escape(initialState);\r\n"
  "      _currentState = _initialState;\r\n"
  "    }\r\n"
  "    _onStateChange.push(onStateChange);\r\n"
  "  },\r\n"
  "  initialize: function (stateField, histFrame) {\r\n"
  "    if (_initialized) {\r\n"
  "      return;\r\n"
  "    }\r\n"
  "    var vendor = navigator.vendor || \"\";\r\n"
  "    if (vendor === \"KDE\") {\r\n"
  "    } else if (typeof window.opera !== \"undefined\")\r\n"
  "      _UAopera = true;\r\n"
  "\r\n"
  "    if (typeof stateField === \"string\")\r\n"
  "      stateField = document.getElementById(stateField);\r\n"
  "    if (!stateField ||\r\n"
  "	stateField.tagName.toUpperCase() !== \"TEXTAREA\" &&\r\n"
  "	(stateField.tagName.toUpperCase() !== \"INPUT\" ||\r\n"
  "	 stateField.type !== \"hidden\" &&\r\n"
  "	 stateField.type !== \"text\")) {\r\n"
  "      return;\r\n"
  "    }\r\n"
  "    _stateField = stateField;\r\n"
  "    if (_UAie) {\r\n"
  "      if (typeof histFrame === \"string\") {\r\n"
  "	histFrame = document.getElementById(histFrame);\r\n"
  "      }\r\n"
  "      if (!histFrame || histFrame.tagName.toUpperCase() !== \"IFRAME\") {\r\n"
  "	return;\r\n"
  "      }\r\n"
  "      _histFrame = histFrame;\r\n"
  "    }\r\n"
  "  },\r\n"
  "  navigate: function (state, generateEvent) {\r\n"
  "    state = gentleURIEncode(state);\r\n"
  "\r\n"
  "    if (!_initialized) {\r\n"
  "      return;\r\n"
  "    }\r\n"
  "    var fqstate = state;\r\n"
  "    if (_UAie) {\r\n"
  "      _updateIFrame(fqstate);\r\n"
  "    } else {\r\n"
  "      if (fqstate.length > 0) {\r\n"
  "	location.hash = fqstate;\r\n"
  "      }\r\n"
  "    }\r\n"
  "    if (generateEvent)\r\n"
  "      onStateChange();\r\n"
  "  },\r\n"
  "  getCurrentState: function () {\r\n"
  "    if (!_initialized) {\r\n"
  "      return \"\";\r\n"
  "    }\r\n"
  "    return unescape(_currentState);\r\n"
  "  }\r\n"
  "  };\r\n"
  "})();\r\n"
  "\r\n"
  "}\r\n"
  "\r\n"
  "})();\r\n"
  "\r\n"
  "if (window._$_APP_CLASS_$_ && window._$_APP_CLASS_$_._p_) {\r\n"
  "  try {\r\n"
  "    window._$_APP_CLASS_$_._p_.quit(null);\r\n"
  "  } catch (e) {\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "window._$_APP_CLASS_$_ = new (function() {\r\n"
  "\r\n"
  "var self = this;\r\n"
  "var WT = _$_WT_CLASS_$_;\r\n"
  "/** @const */ var UNDEFINED = 'undefined';\r\n"
  "/** @const */ var UNKNOWN = 'unknown'; // seen on IE for reasons unknown\r\n"
  "\r\n"
  "var downX = 0;\r\n"
  "var downY = 0;\r\n"
  "\r\n"
  "var deployUrl = _$_DEPLOY_PATH_$_;\r\n"
  "\r\n"
  "function saveDownPos(e) {\r\n"
  "  var coords = WT.pageCoordinates(e);\r\n"
  "  downX = coords.x;\r\n"
  "  downY = coords.y;\r\n"
  "};\r\n"
  "\r\n"
  "var currentHash = null;\r\n"
  "\r\n"
  "function onHashChange() {\r\n"
  "  var newLocation = _$_WT_CLASS_$_.history.getCurrentState();\r\n"
  "\r\n"
  "  if (newLocation != null &&\r\n"
  "      newLocation.length > 0 &&\r\n"
  "      newLocation.substr(0, 1) != '/')\r\n"
  "    return;\r\n"
  "\r\n"
  "  if (currentHash == newLocation)\r\n"
  "    return;\r\n"
  "\r\n"
  "  currentHash = newLocation;\r\n"
  "\r\n"
  "  setTimeout(function() { update(null, 'hash', null, true); }, 1);\r\n"
  "};\r\n"
  "\r\n"
  "function setHash(newLocation, generateEvent) {\r\n"
  "  if (currentHash == newLocation || (!currentHash && newLocation == '/'))\r\n"
  "    return;\r\n"
  "\r\n"
  "  if (!generateEvent)\r\n"
  "    currentHash = newLocation;\r\n"
  "\r\n"
  "  WT.history.navigate(newLocation, generateEvent);\r\n"
  "};\r\n"
  "\r\n"
  "var dragState = {\r\n"
  "  object: null,\r\n"
  "  sourceId: null,\r\n"
  "  mimeType: null,\r\n"
  "  dropOffsetX: null,\r\n"
  "  dragOffsetY: null,\r\n"
  "  dropTarget: null,\r\n"
  "  objectPrevStyle: null,\r\n"
  "  xy: null\r\n"
  "};\r\n"
  "\r\n"
  "var touchTimer;\r\n"
  "var touchduration = 1000;\r\n"
  "\r\n"
  "function touchStart(obj, e) {\r\n"
  "  touchTimer = setTimeout(function(){dragStart(obj,e);}, touchduration);\r\n"
  "}\r\n"
  "\r\n"
  "function touchEnded(){\r\n"
  "  if (touchTimer)\r\n"
  "    clearTimeout(touchTimer);\r\n"
  "}\r\n"
  "\r\n"
  "function dragStart(obj, e) {\r\n"
  "  if (e.touches) {\r\n"
  "    if (\"vibrate\" in navigator) {\r\n"
  "      navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;\r\n"
  "      if (navigator.vibrate) \r\n"
  "	navigator.vibrate(100);\r\n"
  "    }\r\n"
  "  }\r\n"
  "  if ((e.ctrlKey || WT.button(e) > 1) && !e.touches) //Ignore drags with rigth click.\r\n"
  "    return true;\r\n"
  "  var t = WT.target(e);\r\n"
  "  if (t) {\r\n"
  "    /*\r\n"
  "     * Ignore drags that start on a scrollbar (#1231)\r\n"
  "     */\r\n"
  "    if (WT.css(t, 'display') !== 'inline' &&\r\n"
  "	(t.offsetWidth > t.clientWidth ||\r\n"
  "	 t.offsetHeight > t.clientHeight)) {\r\n"
  "      var wc = WT.widgetPageCoordinates(t);\r\n"
  "      var pc = WT.pageCoordinates(e);\r\n"
  "      var x = pc.x - wc.x;\r\n"
  "      var y = pc.y - wc.y;\r\n"
  "      if (x > t.clientWidth || y > t.clientHeight)\r\n"
  "	return true;\r\n"
  "    }\r\n"
  "  }\r\n"
  "\r\n"
  "  // drag element attributes:\r\n"
  "  //   dwid = dragWidgetId\r\n"
  "  //   dsid = dragSourceId\r\n"
  "  //   dmt = dragMimeType\r\n"
  "  // drop element attributes:\r\n"
  "  //   amts = acceptMimeTypes\r\n"
  "  //   ds = dropSignal\r\n"
  "\r\n"
  "  var ds = dragState;\r\n"
  "\r\n"
  "  ds.object = WT.getElement(obj.getAttribute(\"dwid\"));\r\n"
  "  if (ds.object == null)\r\n"
  "    return true;\r\n"
  "\r\n"
  "  ds.sourceId = obj.getAttribute(\"dsid\");\r\n"
  "  ds.objectPrevStyle = {\r\n"
  "    position: ds.object.style.position,\r\n"
  "    display: ds.object.style.display,\r\n"
  "    left: ds.object.style.left,\r\n"
  "    top: ds.object.style.top,\r\n"
  "    className: ds.object.className,\r\n"
  "    parent: ds.object.parentNode,\r\n"
  "    zIndex: ds.object.zIndex\r\n"
  "  };\r\n"
  "\r\n"
  "  ds.object.parentNode.removeChild(ds.object);\r\n"
  "  ds.object.style.position = 'absolute';\r\n"
  "  ds.object.className = ds.objectPrevStyle.className + '';\r\n"
  "  ds.object.style.zIndex = '1000';\r\n"
  "  document.body.appendChild(ds.object);\r\n"
  "\r\n"
  "  WT.capture(null);\r\n"
  "  WT.capture(ds.object);\r\n"
  "\r\n"
  "  ds.object.onmousemove = dragDrag;\r\n"
  "  ds.object.onmouseup = dragEnd;\r\n"
  "  if (document.addEventListener) {\r\n"
  "    // New mousedown (other button): abort drag\r\n"
  "    document.addEventListener('mousedown', dragAbort);\r\n"
  "    // Release mouse outside of page (fires after ds.object.onmouseup)\r\n"
  "    window.addEventListener('mouseup', dragAbort);\r\n"
  "    // Another touch: abort drag\r\n"
  "    document.addEventListener('touchstart', dragAbort);\r\n"
  "  } else {\r\n"
  "    document.attachEvent('onmousedown', dragAbort);\r\n"
  "    window.attachEvent('onmouseup', dragAbort);\r\n"
  "  }\r\n"
  "  ds.object.ontouchmove = dragDrag;\r\n"
  "  ds.object.ontouchend = dragEnd;\r\n"
  "\r\n"
  "  ds.offsetX = -4;\r\n"
  "  ds.offsetY = -4;\r\n"
  "  ds.dropTarget = null;\r\n"
  "  ds.mimeType = obj.getAttribute(\"dmt\");\r\n"
  "  ds.xy = WT.pageCoordinates(e);\r\n"
  "\r\n"
  "  WT.cancelEvent(e, WT.CancelPropagate);\r\n"
  "\r\n"
  "  return false;\r\n"
  "};\r\n"
  "\r\n"
  "function dragDrag(e) {\r\n"
  "  e = e || window.event;\r\n"
  "  if (dragState.object !== null) {\r\n"
  "    var ds = dragState;\r\n"
  "    var xy = WT.pageCoordinates(e);\r\n"
  "\r\n"
  "    if (ds.object.style.display !== '' &&\r\n"
  "	ds.xy.x !== xy.x &&\r\n"
  "	ds.xy.y !== xy.y)\r\n"
  "      ds.object.style.display = '';\r\n"
  "\r\n"
  "    ds.object.style.left = (xy.x - ds.offsetX) + 'px';\r\n"
  "    ds.object.style.top = (xy.y - ds.offsetY) + 'px';\r\n"
  "\r\n"
  "    var prevDropTarget = ds.dropTarget;\r\n"
  "    var t;\r\n"
  "    if (e.changedTouches) {\r\n"
  "	ds.object.style['display']='none';\r\n"
  "	t = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);\r\n"
  "	ds.object.style['display']='';\r\n"
  "     } else {\r\n"
  "	t = WT.target(e);\r\n"
  "        if (t == ds.object) {\r\n"
  "          if (document.elementFromPoint) {\r\n"
  "	    ds.object.style['display']='none';\r\n"
  "	    t = document.elementFromPoint(e.clientX, e.clientY);\r\n"
  "	    ds.object.style['display']='';\r\n"
  "      	  } \r\n"
  "    	}\r\n"
  "      } \r\n"
  "\r\n"
  "    var mimeType = \"{\" + ds.mimeType + \":\";\r\n"
  "    var amts = null;\r\n"
  "\r\n"
  "    ds.dropTarget = null;\r\n"
  "\r\n"
  "    while (t) {\r\n"
  "      amts = t.getAttribute(\"amts\");\r\n"
  "      if ((amts != null) && (amts.indexOf(mimeType) != -1)) {\r\n"
  "	ds.dropTarget = t;\r\n"
  "	break;\r\n"
  "      }\r\n"
  "      t = t.parentNode;\r\n"
  "      if (!t.tagName || WT.hasTag(t, \"HTML\"))\r\n"
  "	break;\r\n"
  "    }\r\n"
  "\r\n"
  "    if (ds.dropTarget != prevDropTarget) {\r\n"
  "      if (ds.dropTarget) {\r\n"
  "        var s = amts.indexOf(mimeType) + mimeType.length;\r\n"
  "	var se = amts.indexOf(\"}\", s);\r\n"
  "	var style = amts.substring(s, se);\r\n"
  "	if (style.length != 0) {\r\n"
  "          ds.dropTarget.setAttribute(\"dos\", ds.dropTarget.className);\r\n"
  "	  ds.dropTarget.className = ds.dropTarget.className + \" \" + style;\r\n"
  "        }\r\n"
  "      } else {\r\n"
  "        ds.object.styleClass = '';\r\n"
  "      }\r\n"
  "\r\n"
  "      if (prevDropTarget != null) {\r\n"
  "	if (prevDropTarget.handleDragDrop){\r\n"
  "	  prevDropTarget.handleDragDrop('end', ds.object, e, '', mimeType);}\r\n"
  "	var dos = prevDropTarget.getAttribute(\"dos\");\r\n"
  "        if (dos != null)\r\n"
  "	  prevDropTarget.className = dos;\r\n"
  "      }\r\n"
  "    } \r\n"
  "\r\n"
  "    if (ds.dropTarget) {\r\n"
  "      if (ds.dropTarget.handleDragDrop)\r\n"
  "	ds.dropTarget.handleDragDrop('drag', ds.object, e, '', mimeType);\r\n"
  "      else\r\n"
  "	ds.object.className = ds.objectPrevStyle.className + ' Wt-valid-drop';\r\n"
  "    } else \r\n"
  "      ds.object.className = ds.objectPrevStyle.className + '';\r\n"
  "    return false;\r\n"
  "  }\r\n"
  "  return true;\r\n"
  "};\r\n"
  "\r\n"
  "function dragAbort() {\r\n"
  "  WT.capture(null);\r\n"
  "\r\n"
  "  var ds = dragState;\r\n"
  "\r\n"
  "  if (ds.object) {\r\n"
  "    document.body.removeChild(ds.object);\r\n"
  "    ds.objectPrevStyle.parent.appendChild(ds.object);\r\n"
  "\r\n"
  "    ds.object.style.zIndex = ds.objectPrevStyle.zIndex;\r\n"
  "    ds.object.style.position = ds.objectPrevStyle.position;\r\n"
  "    ds.object.style.display = ds.objectPrevStyle.display;\r\n"
  "    ds.object.style.left = ds.objectPrevStyle.left;\r\n"
  "    ds.object.style.top = ds.objectPrevStyle.top;\r\n"
  "    ds.object.className = ds.objectPrevStyle.className;\r\n"
  "\r\n"
  "    ds.object = null;\r\n"
  "    if (touchTimer)\r\n"
  "      clearTimeout(touchTimer);\r\n"
  "  }\r\n"
  "\r\n"
  "  if (document.removeEventListener) {\r\n"
  "    document.removeEventListener('mousedown', dragAbort);\r\n"
  "    window.removeEventListener('mouseup', dragAbort);\r\n"
  "    document.removeEventListener('touchstart', dragAbort);\r\n"
  "  } else {\r\n"
  "    document.detachEvent('onmousedown', dragAbort);\r\n"
  "    window.detachEvent('onmouseup', dragAbort);\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "function dragEnd(e) {\r\n"
  "  e = e || window.event;\r\n"
  "  WT.capture(null);\r\n"
  "\r\n"
  "  var ds = dragState;\r\n"
  "\r\n"
  "  if (ds.object) {\r\n"
  "    if (ds.dropTarget) {\r\n"
  "      var dos = ds.dropTarget.getAttribute(\"dos\");\r\n"
  "      if (dos != null){\r\n"
  "	  ds.dropTarget.className = dos;}\r\n"
  "      if (ds.dropTarget.handleDragDrop){\r\n"
  "	ds.dropTarget.handleDragDrop('drop', ds.object, e,\r\n"
  "				     ds.sourceId, ds.mimeType);\r\n"
  "      }else{\r\n"
  " 	if (e.touches)\r\n"
  "	  emit(ds.dropTarget, {name: \"_drop2\", eventObject: ds.dropTarget,\r\n"
  "	      event: e}, ds.sourceId, ds.mimeType);\r\n"
  "	else\r\n"
  "	  emit(ds.dropTarget, {name: \"_drop\", eventObject: ds.dropTarget,\r\n"
  "	      event: e}, ds.sourceId, ds.mimeType);\r\n"
  "      }\r\n"
  "    } else {\r\n"
  "      // could not be dropped, animate it floating back ?\r\n"
  "    }\r\n"
  "\r\n"
  "    dragAbort();\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "function encodeTouches(touches, widgetCoords) {\r\n"
  "  var i, il, result;\r\n"
  "\r\n"
  "  result = '';\r\n"
  "\r\n"
  "  for (i = 0, il = touches.length; i < il; ++i) {\r\n"
  "    var t = touches[i];\r\n"
  "    if (i != 0)\r\n"
  "      result += ';';\r\n"
  "    result += [ t.identifier,\r\n"
  "		Math.round(t.clientX), Math.round(t.clientY),\r\n"
  "		Math.round(t.pageX), Math.round(t.pageY),\r\n"
  "		Math.round(t.screenX), Math.round(t.screenY),\r\n"
  "		Math.round(t.pageX - widgetCoords.x),\r\n"
  "		Math.round(t.pageY - widgetCoords.y) ].join(';');\r\n"
  "  }\r\n"
  "\r\n"
  "  return result;\r\n"
  "}\r\n"
  "\r\n"
  "var formObjects = [];\r\n"
  "\r\n"
  "function encodeEvent(event, i) {\r\n"
  "  var se, result, e;\r\n"
  "\r\n"
  "  e = event.event;\r\n"
  "  result = ['signal=' + event.signal];\r\n"
  "\r\n"
  "  if (event.id) {\r\n"
  "    result.push('id=' + event.id,\r\n"
  "                'name=' + encodeURIComponent(event.name),\r\n"
  "                'an=' + event.args.length);\r\n"
  "\r\n"
  "    for (var j = 0; j < event.args.length; ++j)\r\n"
  "      result.push('a' + j + '=' + encodeURIComponent(event.args[j]));\r\n"
  "  }\r\n"
  "\r\n"
  "  for (var x = 0; x < formObjects.length; ++x) {\r\n"
  "    var el = WT.getElement(formObjects[x]), v = null, j, jl;\r\n"
  "\r\n"
  "    if (el == null)\r\n"
  "      continue;\r\n"
  "\r\n"
  "    if (el.wtEncodeValue)\r\n"
  "      v = el.wtEncodeValue(el);\r\n"
  "    else if (el.type == 'select-multiple') {\r\n"
  "      for (j = 0, jl = el.options.length; j < jl; j++)\r\n"
  "	if (el.options[j].selected) {\r\n"
  "          result.push(formObjects[x] + '='\r\n"
  "              + encodeURIComponent(el.options[j].value));\r\n"
  "	}\r\n"
  "    } else if (el.type == 'checkbox' || el.type == 'radio') {\r\n"
  "      if (el.indeterminate || el.style.opacity == '0.5')\r\n"
  "	v = 'i';\r\n"
  "      else if (el.checked)\r\n"
  "	v = el.value;\r\n"
  "    } else if (el.type != 'file') {\r\n"
  "      if ($(el).hasClass('Wt-edit-emptyText'))\r\n"
  "	v = '';\r\n"
  "      else {\r\n"
  "	/* For WTextEdit */\r\n"
  "	if (el.ed)\r\n"
  "	  el.ed.save();\r\n"
  "	v = '' + el.value;\r\n"
  "      }\r\n"
  "\r\n"
  "      if (WT.hasFocus(el)) {\r\n"
  "	var range = WT.getUnicodeSelectionRange(el);\r\n"
  "        result.push('selstart=' + range.start,\r\n"
  "                    'selend=' + range.end);\r\n"
  "      }\r\n"
  "    }\r\n"
  "\r\n"
  "    if (v != null) {\r\n"
  "      var component;\r\n"
  "      try {\r\n"
  "	component = encodeURIComponent(v);\r\n"
  "        result.push(formObjects[x] + '=' + component);\r\n"
  "      } catch (e) {\r\n"
  "	// encoding failed, omit this form field\r\n"
  "	// This can happen on Windows when typing a character\r\n"
  "	// with a high and low surrogate pair (like an emoji).\r\n"
  "	// On Chrome and Firefox this is split out into two pairs\r\n"
  "	// of keydown/keyup events instead of one.\r\n"
  "	console.error(\"Form object \" + formObjects[x] + \" failed to encode, discarded\", e);\r\n"
  "      }\r\n"
  "    }\r\n"
  "  }\r\n"
  "\r\n"
  "\r\n"
  "  try {\r\n"
  "    if (document.activeElement)\r\n"
  "      result.push('focus=' + document.activeElement.id);\r\n"
  "  } catch (e) { }\r\n"
  "\r\n"
  "  if (currentHash != null)\r\n"
  "    result.push('_=' + encodeURIComponent(currentHash));\r\n"
  "\r\n"
  "  if (!e) {\r\n"
  "    event.data = result;\r\n"
  "    return event;\r\n"
  "  }\r\n"
  "\r\n"
  "  var t = WT.target(e);\r\n"
  "  while (t && !t.id && t.parentNode)\r\n"
  "    t = t.parentNode;\r\n"
  "  if (t && t.id)\r\n"
  "    result.push('tid=' + t.id);\r\n"
  "\r\n"
  "  try {\r\n"
  "    if (typeof e.type === 'string')\r\n"
  "      result.push('type=' + e.type);\r\n"
  "  } catch (e) {\r\n"
  "  }\r\n"
  "\r\n"
  "  if (typeof e.clientX !== UNDEFINED && \r\n"
  "      typeof e.clientX !== UNKNOWN)\r\n"
  "    result.push('clientX=' + Math.round(e.clientX),\r\n"
  "                'clientY=' + Math.round(e.clientY));\r\n"
  "\r\n"
  "  var pageCoords = WT.pageCoordinates(e);\r\n"
  "  var posX = pageCoords.x;\r\n"
  "  var posY = pageCoords.y;\r\n"
  "\r\n"
  "  if (posX || posY) {\r\n"
  "    result.push('documentX=' + Math.round(posX),\r\n"
  "                'documentY=' + Math.round(posY),\r\n"
  "                'dragdX=' + Math.round(posX - downX),\r\n"
  "                'dragdY=' + Math.round(posY - downY));\r\n"
  "\r\n"
  "    var delta = WT.wheelDelta(e);\r\n"
  "    result.push('wheel=' + Math.round(delta));\r\n"
  "  }\r\n"
  "\r\n"
  "  if (typeof e.screenX !== UNDEFINED &&\r\n"
  "      typeof e.screenX !== UNKNOWN)\r\n"
  "    result.push('screenX=' + Math.round(e.screenX),\r\n"
  "                'screenY=' + Math.round(e.screenY));\r\n"
  "\r\n"
  "  var widgetCoords = { x: 0, y: 0 };\r\n"
  "\r\n"
  "  if (event.object && event.object.nodeType != 9) {\r\n"
  "    widgetCoords = WT.widgetPageCoordinates(event.object);\r\n"
  "    var objX = widgetCoords.x;\r\n"
  "    var objY = widgetCoords.y;\r\n"
  "\r\n"
  "    if (typeof event.object.scrollLeft !== UNDEFINED &&\r\n"
  "	typeof event.object.scrollLeft !== UNKNOWN) {\r\n"
  "      result.push('scrollX=' + Math.round(event.object.scrollLeft),\r\n"
  "                  'scrollY=' + Math.round(event.object.scrollTop),\r\n"
  "                  'width=' + Math.round(event.object.clientWidth),\r\n"
  "                  'height=' + Math.round(event.object.clientHeight));\r\n"
  "    }\r\n"
  "\r\n"
  "    result.push('widgetX=' + Math.round(posX - objX),\r\n"
  "                'widgetY=' + Math.round(posY - objY));\r\n"
  "  }\r\n"
  "\r\n"
  "  var button = WT.button(e);\r\n"
  "  if (!button) {\r\n"
  "    if (WT.buttons & 1)\r\n"
  "      button = 1;\r\n"
  "    else if (WT.buttons & 2)\r\n"
  "      button = 2;\r\n"
  "    else if (WT.buttons & 4)\r\n"
  "      button = 4;\r\n"
  "  }\r\n"
  "  result.push('button=' + button);\r\n"
  "\r\n"
  "  if (typeof e.keyCode !== UNDEFINED && \r\n"
  "      typeof e.keyCode !== UNKNOWN)\r\n"
  "    result.push('keyCode=' + e.keyCode);\r\n"
  "\r\n"
  "  if (typeof e.type === 'string') {\r\n"
  "    var charCode = 0;\r\n"
  "    if (typeof e.charCode !== UNDEFINED) {\r\n"
  "      if (e.type === 'keypress')\r\n"
  "	charCode = e.charCode;\r\n"
  "    } else {\r\n"
  "      if (e.type === 'keypress')\r\n"
  "	charCode = e.keyCode;\r\n"
  "    }\r\n"
  "    result.push('charCode=' + charCode);\r\n"
  "  }\r\n"
  "\r\n"
  "  if (typeof e.altKey !== UNDEFINED && \r\n"
  "      typeof e.altKey !== UNKNOWN &&\r\n"
  "      e.altKey)\r\n"
  "    result.push('altKey=1');\r\n"
  "  if (typeof e.ctrlKey !== UNDEFINED &&\r\n"
  "      typeof e.ctrlKey !== UNKNOWN &&\r\n"
  "      e.ctrlKey)\r\n"
  "    result.push('ctrlKey=1');\r\n"
  "  if (typeof e.metaKey !== UNDEFINED &&\r\n"
  "      typeof e.metaKey !== UNKNOWN &&\r\n"
  "      e.metaKey)\r\n"
  "    result.push('metaKey=1');\r\n"
  "  if (typeof e.shiftKey !== UNDEFINED && typeof e.shiftKey !== UNKNOWN &&\r\n"
  "      e.shiftKey)\r\n"
  "    result.push('shiftKey=1');\r\n"
  "\r\n"
  "  if (typeof e.touches !== UNDEFINED)\r\n"
  "    result.push('touches=' + encodeTouches(e.touches, widgetCoords));\r\n"
  "  if (typeof e.targetTouches !== UNDEFINED)\r\n"
  "    result.push('ttouches=' + encodeTouches(e.targetTouches, widgetCoords));\r\n"
  "  if (typeof e.changedTouches !== UNDEFINED)\r\n"
  "    result.push('ctouches=' + encodeTouches(e.changedTouches, widgetCoords));\r\n"
  "\r\n"
  "  if (typeof e.scale !== UNDEFINED &&\r\n"
  "      typeof e.scale !== UNKNOWN &&\r\n"
  "      e.scale)\r\n"
  "    result.push('scale=' + e.scale);\r\n"
  "  if (typeof e.rotation !== UNDEFINED &&\r\n"
  "      typeof e.rotation !== UNKNOWN &&\r\n"
  "      e.rotation)\r\n"
  "    result.push('rotation=' + e.rotation);\r\n"
  "\r\n"
  "  event.data = result;\r\n"
  "  return event;\r\n"
  "};\r\n"
  "\r\n"
  "var sentEvents = [], pendingEvents = [];\r\n"
  "\r\n"
  "function encodePendingEvents() {\r\n"
  "  var se, result = '', feedback = false;\r\n"
  "\r\n"
  "  for (var i = 0; i < pendingEvents.length; ++i) {\r\n"
  "    se = i > 0 ? '&e' + i : '&';\r\n"
  "    feedback = feedback || pendingEvents[i].feedback;\r\n"
  "    result += se + pendingEvents[i].data.join(se);\r\n"
  "    if (pendingEvents[i].evAckId < ackUpdateId) {\r\n"
  "      result += se + 'evAckId=' + pendingEvents[i].evAckId;\r\n"
  "    }\r\n"
  "  }\r\n"
  "\r\n"
  "  // With HTTP: sentEvents should be empty before this concat\r\n"
  "  // With WebSockets: sentEvents possibly not empty\r\n"
  "  sentEvents = sentEvents.concat(pendingEvents);\r\n"
  "  pendingEvents = [];\r\n"
  "\r\n"
  "  return { feedback: feedback, result: result };\r\n"
  "}\r\n"
  "\r\n"
  "var sessionUrl,\r\n"
  "  hasQuit = false,\r\n"
  "  quitStr = _$_QUITTED_STR_$_,\r\n"
  "  loaded = false,\r\n"
  "  responsePending = null,\r\n"
  "  pollTimer = null,\r\n"
  "  keepAliveTimer = null,\r\n"
  "  idleTimeout = _$_IDLE_TIMEOUT_$_, /* idle timeout in seconds, null if disabled */\r\n"
  "  idleTimeoutTimer = null,\r\n"
  "  commErrors = 0,\r\n"
  "  serverPush = false,\r\n"
  "  updateTimeout = null;\r\n"
  "\r\n"
  "function quit(hasQuitMessage) {\r\n"
  "  hasQuit = true;\r\n"
  "  quitStr = hasQuitMessage;\r\n"
  "  if (keepAliveTimer) {\r\n"
  "    clearInterval(keepAliveTimer);\r\n"
  "    keepAliveTimer = null;\r\n"
  "  }\r\n"
  "  if (idleTimeoutTimer) {\r\n"
  "    clearTimeout(idleTimeoutTimer);\r\n"
  "    idleTimeoutTimer = null;\r\n"
  "  }\r\n"
  "  if (pollTimer) {\r\n"
  "    clearTimeout(pollTimer);\r\n"
  "    pollTimer = null;\r\n"
  "  }\r\n"
  "  comm.cancel();\r\n"
  "  var tr = $('#Wt-timers');\r\n"
  "  if (tr.size() > 0)\r\n"
  "    WT.setHtml(tr.get(0), '', false);\r\n"
  "}\r\n"
  "\r\n"
  "function doKeepAlive() {\r\n"
  "  WT.history._initTimeout();\r\n"
  "  if (commErrors == 0)\r\n"
  "    update(null, 'keepAlive', null, false);\r\n"
  "}\r\n"
  "\r\n"
  "function debug(s) {\r\n"
  "  document.body.innerHTML += s;\r\n"
  "}\r\n"
  "\r\n"
  "function setTitle(title) {\r\n"
  "  if (WT.isIEMobile) return;\r\n"
  "  document.title = title;\r\n"
  "}\r\n"
  "\r\n"
  "function doIdleTimeout() {\r\n"
  "  self.emit(self, 'Wt-idleTimeout');\r\n"
  "  idleTimeoutTimer = setTimeout(doIdleTimeout, idleTimeout * 1000);\r\n"
  "}\r\n"
  "\r\n"
  "function delayIdleTimeout() {\r\n"
  "  if (idleTimeoutTimer !== null) {\r\n"
  "    clearTimeout(idleTimeoutTimer);\r\n"
  "    idleTimeoutTimer = setTimeout(doIdleTimeout, idleTimeout * 1000);\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "function initIdleTimeout() {\r\n"
  "  var opts = true;\r\n"
  "\r\n"
  "  if (idleTimeout === null)\r\n"
  "    return;\r\n"
  "\r\n"
  "  idleTimeoutTimer = setTimeout(doIdleTimeout, idleTimeout * 1000);\r\n"
  "\r\n"
  "  try {\r\n"
  "    var options = Object.defineProperty({}, \"passive\", {\r\n"
  "      get: function() {\r\n"
  "        //passive supported\r\n"
  "        opts = {\r\n"
  "          capture: true,\r\n"
  "          passive: true\r\n"
  "        };\r\n"
  "      }\r\n"
  "    });\r\n"
  "\r\n"
  "    window.addEventListener('test', options, options);\r\n"
  "    window.removeEventListener('test', options, options);\r\n"
  "  } catch (err) {\r\n"
  "    opts = true; // passive not supported, only specify capture\r\n"
  "  }\r\n"
  "\r\n"
  "  if (document.addEventListener) {\r\n"
  "    document.addEventListener('mousedown', delayIdleTimeout, opts);\r\n"
  "    document.addEventListener('mouseup', delayIdleTimeout, opts);\r\n"
  "    document.addEventListener('wheel', delayIdleTimeout, opts);\r\n"
  "    document.addEventListener('keydown', delayIdleTimeout, opts);\r\n"
  "    document.addEventListener('keyup', delayIdleTimeout, opts);\r\n"
  "    document.addEventListener('touchstart', delayIdleTimeout, opts);\r\n"
  "    document.addEventListener('touchend', delayIdleTimeout, opts);\r\n"
  "    document.addEventListener('pointerdown', delayIdleTimeout, opts);\r\n"
  "    document.addEventListener('pointerup', delayIdleTimeout, opts);\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "function load(fullapp) {\r\n"
  "  if (loaded)\r\n"
  "    return;\r\n"
  "\r\n"
  "  if (fullapp) {\r\n"
  "    if (!window._$_APP_CLASS_$_LoadWidgetTree)\r\n"
  "      return; // That's too soon baby.\r\n"
  "\r\n"
  "    WT.history.initialize(\"Wt-history-field\", \"Wt-history-iframe\", deployUrl);\r\n"
  "  }\r\n"
  "\r\n"
  "  if (!(\"activeElement\" in document)) {\r\n"
  "    function trackActiveElement(evt) {\r\n"
  "      if (evt && evt.target) {\r\n"
  "	document.activeElement = evt.target == document ? null : evt.target;\r\n"
  "      }\r\n"
  "    }\r\n"
  "\r\n"
  "    function trackActiveElementLost(evt) {\r\n"
  "      document.activeElement = null;\r\n"
  "    }\r\n"
  "\r\n"
  "    document.addEventListener(\"focus\", trackActiveElement, true);\r\n"
  "    document.addEventListener(\"blur\", trackActiveElementLost, true);\r\n"
  "  }\r\n"
  "\r\n"
  "  // this could be cancelled leading to havoc?\r\n"
  "  $(document).mousedown(WT.mouseDown).mouseup(WT.mouseUp);\r\n"
  "\r\n"
  "  WT.history._initialize();\r\n"
  "  initIdleTimeout();\r\n"
  "  loaded = true;\r\n"
  "\r\n"
  "  if (fullapp)\r\n"
  "    window._$_APP_CLASS_$_LoadWidgetTree();\r\n"
  "\r\n"
  "  if (!hasQuit) {\r\n"
  "    if (!keepAliveTimer) {\r\n"
  "      keepAliveTimer = setInterval(doKeepAlive, _$_KEEP_ALIVE_$_000);\r\n"
  "    }\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "var currentHideLoadingIndicator = null;\r\n"
  "\r\n"
  "function cancelFeedback(timer) {\r\n"
  "  clearTimeout(timer);\r\n"
  "  document.body.style.cursor = 'auto';\r\n"
  "\r\n"
  "  if (currentHideLoadingIndicator != null) {\r\n"
  "    try {\r\n"
  "      currentHideLoadingIndicator();\r\n"
  "    } catch (e) {\r\n"
  "    }\r\n"
  "    currentHideLoadingIndicator = null;\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "function waitFeedback() {\r\n"
  "  document.body.style.cursor = 'wait';\r\n"
  "  currentHideLoadingIndicator = hideLoadingIndicator;\r\n"
  "  showLoadingIndicator();\r\n"
  "}\r\n"
  "\r\n"
  "var nextWsRqId = 0;\r\n"
  "var pendingWsRequests = {};\r\n"
  "\r\n"
  "function wsWaitFeedback() {\r\n"
  "  var now = Date.now();\r\n"
  "  var maxRqId = -1;\r\n"
  "  for (var wsReq in pendingWsRequests) {\r\n"
  "    if (pendingWsRequests.hasOwnProperty(wsReq)) {\r\n"
  "      if (now - pendingWsRequests[wsReq].time >= _$_INDICATOR_TIMEOUT_$_) {\r\n"
  "        if (currentHideLoadingIndicator == null)\r\n"
  "          waitFeedback();\r\n"
  "        return;\r\n"
  "      }\r\n"
  "      var wsReqI = parseInt(wsReq, 10);\r\n"
  "      if (wsReqI > maxRqId)\r\n"
  "	maxRqId = wsReqI;\r\n"
  "    }\r\n"
  "  }\r\n"
  "  nextWsRqId = maxRqId + 1;\r\n"
  "  // We're not waiting on any WebSocket requests for longer than\r\n"
  "  // INDICATOR_TIMEOUT, so hide the loading indicator and reset\r\n"
  "  // the cursor.\r\n"
  "  document.body.style.cursor = 'auto';\r\n"
  "  if (currentHideLoadingIndicator != null) {\r\n"
  "    try {\r\n"
  "      currentHideLoadingIndicator();\r\n"
  "    } catch (e) {\r\n"
  "    }\r\n"
  "    currentHideLoadingIndicator = null;\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "/** @const */ var WebSocketUnknown = 0;\r\n"
  "/** @const */ var WebSocketConnecting = 1;\r\n"
  "/** @const */ var WebSocketAckConnect = 2;\r\n"
  "/** @const */ var WebSocketWorking = 3;\r\n"
  "/** @const */ var WebSocketUnavailable = 4;\r\n"
  "\r\n"
  "var websocket = {\r\n"
  "  state: WebSocketUnknown,\r\n"
  "  socket: null,\r\n"
  "  keepAlive: null,\r\n"
  "  reconnectTries: 0\r\n"
  "};\r\n"
  "\r\n"
  "var connectionMonitor = null;\r\n"
  "\r\n"
  "function setServerPush(how) {\r\n"
  "  serverPush = how;\r\n"
  "}\r\n"
  "\r\n"
  "function doAutoJavaScript() {\r\n"
  "    self._p_.autoJavaScript();\r\n"
  "}\r\n"
  "\r\n"
  "function doJavaScript(js) {\r\n"
  "  if (js) {\r\n"
  "    js = \"(function() {\" + js + \"})();\";\r\n"
  "    if (window.execScript)\r\n"
  "      window.execScript(js);\r\n"
  "    else\r\n"
  "      window.eval(js);\r\n"
  "  }\r\n"
  "\r\n"
  "  if (self == window._$_APP_CLASS_$_)\r\n"
  "    doAutoJavaScript();\r\n"
  "}\r\n"
  "\r\n"
  "function webSocketAckConnect() {\r\n"
  "  nextWsRqId = 0;\r\n"
  "  pendingWsRequests = {};\r\n"
  "  websocket.socket.send('&signal=none&connected=' + ackUpdateId);\r\n"
  "  websocket.state = WebSocketWorking;\r\n"
  "}\r\n"
  "\r\n"
  "function handleResponse(status, msg, timer) {\r\n"
  "  if (connectionMonitor)\r\n"
  "    connectionMonitor.onStatusChange('connectionStatus', status == 0 ? 1 : 0);\r\n"
  "\r\n"
  "  if (hasQuit)\r\n"
  "    return;\r\n"
  "\r\n"
  "  if (waitingForJavaScript) {\r\n"
  "    setTimeout(function() { handleResponse(status, msg, timer); }, 50);\r\n"
  "    return;\r\n"
  "  }\r\n"
  "\r\n"
  "  if (status == 0) {\r\n"
  "    WT.resolveRelativeAnchors();\r\n"
  "_$_$if_CATCH_ERROR_$_();\r\n"
  "    try {\r\n"
  "_$_$endif_$_();\r\n"
  "      doJavaScript(msg);\r\n"
  "_$_$if_CATCH_ERROR_$_();\r\n"
  "    } catch (e) {\r\n"
  "      var stack = e.stack || e.stacktrace;\r\n"
  "      var description = e.description || e.message;\r\n"
  "      var err = { \"exception_code\": e.code,\r\n"
  "		  \"exception_description\": description,\r\n"
  "		  \"exception_js\": msg };\r\n"
  "      err.stack = stack;\r\n"
  "      sendError(err,\r\n"
  "		\"Wt internal error; code: \" +  e.code\r\n"
  "		+ \", description: \" + description);\r\n"
  "      throw e;\r\n"
  "    }\r\n"
  "_$_$endif_$_();\r\n"
  "\r\n"
  "    if (timer)\r\n"
  "      cancelFeedback(timer);\r\n"
  "  } else {\r\n"
  "    pendingEvents = sentEvents.concat(pendingEvents);\r\n"
  "  }\r\n"
  "\r\n"
  "  sentEvents = [];\r\n"
  "\r\n"
  "  if (pollTimer) {\r\n"
  "    clearTimeout(pollTimer);\r\n"
  "    pollTimer = null;\r\n"
  "  }\r\n"
  "\r\n"
  "  responsePending = null;\r\n"
  "\r\n"
  "  if (status > 0)\r\n"
  "    ++commErrors;\r\n"
  "  else\r\n"
  "    commErrors = 0;\r\n"
  "\r\n"
  "  if (hasQuit)\r\n"
  "    return;\r\n"
  "\r\n"
  "  if (websocket.state == WebSocketAckConnect)\r\n"
  "    webSocketAckConnect();\r\n"
  "\r\n"
  "  if ((serverPush && !waitingForJavaScript) || pendingEvents.length > 0) {\r\n"
  "    if (status == 1) {\r\n"
  "      var ms = Math.min(120000, Math.exp(commErrors) * 500);\r\n"
  "      updateTimeout = setTimeout(function() { sendUpdate(); }, ms);\r\n"
  "    } else if (updateTimeout == null)\r\n"
  "      sendUpdate();\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "function setSessionUrl(url) {\r\n"
  "  if (url.indexOf(\"://\") != -1 || url[0] == '/')\r\n"
  "    sessionUrl = url;\r\n"
  "  else\r\n"
  "    sessionUrl = deployUrl + url;\r\n"
  "\r\n"
  "  if (comm)\r\n"
  "    comm.setUrl(url);\r\n"
  "}\r\n"
  "\r\n"
  "setSessionUrl(_$_SESSION_URL_$_);\r\n"
  "\r\n"
  "var comm = WT.initAjaxComm(sessionUrl, handleResponse);\r\n"
  "\r\n"
  "function doPollTimeout() {\r\n"
  "  responsePending.abort();\r\n"
  "  responsePending = null;\r\n"
  "  pollTimer = null;\r\n"
  "\r\n"
  "  if (!hasQuit)\r\n"
  "    sendUpdate();\r\n"
  "}\r\n"
  "\r\n"
  "function setConnectionMonitor(aMonitor) {\r\n"
  "  connectionMonitor = aMonitor;\r\n"
  "  connectionMonitor.status = {};\r\n"
  "  connectionMonitor.status.connectionStatus = 0;\r\n"
  "  connectionMonitor.status.websocket = false;\r\n"
  "  connectionMonitor.onStatusChange = function(type, newS) {\r\n"
  "    var old = connectionMonitor.status[type];\r\n"
  "    if (old == newS)\r\n"
  "	return;\r\n"
  "    connectionMonitor.status[type] = newS;\r\n"
  "    connectionMonitor.onChange(type, old, newS);\r\n"
  "  };\r\n"
  "}\r\n"
  "\r\n"
  "var updating = false;\r\n"
  "\r\n"
  "function update(el, signalName, e, feedback) {\r\n"
  "  /*\r\n"
  "   * Konqueror may recurisvely call update() because\r\n"
  "   * /reading/ offsetLeft or offsetTop triggers an onscroll event ??\r\n"
  "   */\r\n"
  "  if (updating)\r\n"
  "    return;\r\n"
  "\r\n"
  "  updating = true;\r\n"
  "\r\n"
  "  WT.checkReleaseCapture(el, e);\r\n"
  "\r\n"
  "_$_$if_STRICTLY_SERIALIZED_EVENTS_$_();\r\n"
  "  if (!responsePending) {\r\n"
  "_$_$endif_$_();\r\n"
  "\r\n"
  "  var pendingEvent = new Object(), i = pendingEvents.length;\r\n"
  "  pendingEvent.object = el;\r\n"
  "  pendingEvent.signal = signalName;\r\n"
  "  pendingEvent.event = window.fakeEvent || e;\r\n"
  "  pendingEvent.feedback = feedback;\r\n"
  "  pendingEvent.evAckId = ackUpdateId;\r\n"
  "\r\n"
  "  pendingEvents[i] = encodeEvent(pendingEvent, i);\r\n"
  "\r\n"
  "  scheduleUpdate();\r\n"
  "\r\n"
  "  doJavaScript();\r\n"
  "\r\n"
  "_$_$if_STRICTLY_SERIALIZED_EVENTS_$_();\r\n"
  "  }\r\n"
  "_$_$endif_$_();\r\n"
  "\r\n"
  "  updating = false;\r\n"
  "}\r\n"
  "\r\n"
  "var updateTimeoutStart;\r\n"
  "\r\n"
  "function schedulePing() {\r\n"
  "  if (websocket.keepAlive)\r\n"
  "    clearInterval(websocket.keepAlive);\r\n"
  "\r\n"
  "  websocket.keepAlive = setInterval\r\n"
  "    (function() {\r\n"
  "      var ws = websocket.socket;\r\n"
  "      if (ws.readyState == 1)\r\n"
  "	ws.send('&signal=ping');\r\n"
  "      else {\r\n"
  "	clearInterval(websocket.keepAlive);\r\n"
  "	websocket.keepAlive = null;\r\n"
  "      }\r\n"
  "    }, _$_SERVER_PUSH_TIMEOUT_$_);\r\n"
  "}\r\n"
  "\r\n"
  "function scheduleUpdate() {\r\n"
  "  if (hasQuit) {\r\n"
  "    if (!quitStr)\r\n"
  "      return;\r\n"
  "    if (confirm(quitStr)) {\r\n"
  "      document.location = document.location;\r\n"
  "      quitStr = null;\r\n"
  "      return;\r\n"
  "    } else {\r\n"
  "      quitStr = null;\r\n"
  "      return;\r\n"
  "    }\r\n"
  "  }\r\n"
  "\r\n"
  "_$_$if_WEB_SOCKETS_$_();\r\n"
  "  if (websocket.state != WebSocketUnavailable) {\r\n"
  "    if (typeof window.WebSocket === UNDEFINED\r\n"
  "        && typeof window.MozWebSocket === UNDEFINED)\r\n"
  "      websocket.state = WebSocketUnavailable;\r\n"
  "    else {\r\n"
  "      var ws = websocket.socket;\r\n"
  "\r\n"
  "      if ((ws == null || ws.readyState > 1)) {\r\n"
  "	if (ws != null && websocket.state == WebSocketUnknown)\r\n"
  "	  websocket.state = WebSocketUnavailable;\r\n"
  "	else {\r\n"
  "	  function reconnect() {\r\n"
  "	    if (!hasQuit) {\r\n"
  "	      ++websocket.reconnectTries;\r\n"
  "	      var ms = Math.min(120000, Math.exp(websocket.reconnectTries)\r\n"
  "				* 500);\r\n"
  "	      setTimeout(function() { scheduleUpdate(); }, ms);\r\n"
  "	    }\r\n"
  "	  }\r\n"
  "\r\n"
  "	  var protocolEnd = sessionUrl.indexOf(\"://\"), wsurl;\r\n"
  "	  if (protocolEnd != -1) {\r\n"
  "	    wsurl = \"ws\" + sessionUrl.substr(4);\r\n"
  "	  } else {\r\n"
  "	    var query = sessionUrl.substr(sessionUrl.indexOf('?'));\r\n"
  "	    wsurl = \"ws\" + location.protocol.substr(4)\r\n"
  "	      + \"//\" + location.host + _$_WS_PATH_$_ + query;\r\n"
  "	  }\r\n"
  "\r\n"
  "	  wsurl += \"&request=ws\";\r\n"
  "\r\n"
  "	  var wsid = _$_WS_ID_$_;\r\n"
  "	  if (wsid.length > 0)\r\n"
  "	    wsurl += \"&wsid=\" + wsid;\r\n"
  "\r\n"
  "	  if (typeof window.WebSocket !== UNDEFINED)\r\n"
  "	    websocket.socket = ws = new WebSocket(wsurl);\r\n"
  "	  else\r\n"
  "	    websocket.socket = ws = new MozWebSocket(wsurl);\r\n"
  "\r\n"
  "	  websocket.state = WebSocketConnecting;\r\n"
  "\r\n"
  "	  if (websocket.keepAlive)\r\n"
  "	    clearInterval(websocket.keepAlive);\r\n"
  "	  websocket.keepAlive = null;\r\n"
  "\r\n"
  "	  ws.onmessage = function(event) {\r\n"
  "	    var js = null;\r\n"
  "\r\n"
  "	    if (websocket.state == WebSocketConnecting) {\r\n"
  "	      if (event.data == \"connect\") {\r\n"
  "		if (responsePending != null && pollTimer != null) {\r\n"
  "		  clearTimeout(pollTimer);\r\n"
  "		  pollTimer = null;\r\n"
  "		  responsePending.abort();\r\n"
  "		  responsePending = null;\r\n"
  "		}\r\n"
  "\r\n"
  "                if (responsePending ||\r\n"
  "                    !$.isEmptyObject(pendingWsRequests))\r\n"
  "                  websocket.state = WebSocketAckConnect;\r\n"
  "                else\r\n"
  "		  webSocketAckConnect();\r\n"
  "	      } else {\r\n"
  "		console.log(\"WebSocket: was expecting a connect?\");\r\n"
  "		console.log(event.data);\r\n"
  "		return;\r\n"
  "	      }\r\n"
  "	    } else {\r\n"
  "	      if (connectionMonitor) {\r\n"
  "		connectionMonitor.onStatusChange('websocket', true);\r\n"
  "		connectionMonitor.onStatusChange('connectionStatus', 1);\r\n"
  "	      }\r\n"
  "              websocket.state = WebSocketWorking;\r\n"
  "	      js = event.data;\r\n"
  "	    }\r\n"
  "\r\n"
  "	    websocket.reconnectTries = 0;\r\n"
  "	    if (js != null)\r\n"
  "              handleResponse(0, js, null);\r\n"
  "	  };\r\n"
  "\r\n"
  "	  ws.onerror = function(event) {\r\n"
  "	    /*\r\n"
  "	     * Sometimes, we can connect but cannot send data\r\n"
  "	     */\r\n"
  "	    if (connectionMonitor)\r\n"
  "	      connectionMonitor.onStatusChange('websocket', false);\r\n"
  "	    if (websocket.reconnectTries == 3 &&\r\n"
  "		websocket.state == WebSocketUnknown)\r\n"
  "	      websocket.state = WebSocketUnavailable;\r\n"
  "	    reconnect();\r\n"
  "	  };\r\n"
  "\r\n"
  "	  ws.onclose = function(event) {\r\n"
  "	    /*\r\n"
  "	     * Sometimes, we can connect but cannot send data\r\n"
  "	     */\r\n"
  "	    if (connectionMonitor)\r\n"
  "	      connectionMonitor.onStatusChange('websocket', false);\r\n"
  "	    if (websocket.reconnectTries == 3 &&\r\n"
  "		websocket.state == WebSocketUnknown)\r\n"
  "	      websocket.state = WebSocketUnavailable;\r\n"
  "	    reconnect();\r\n"
  "	  };\r\n"
  "\r\n"
  "	  ws.onopen = function(event) {\r\n"
  "	    /*\r\n"
  "	     * WebSockets are suppossedly reliable, but there is nothing\r\n"
  "	     * in the protocol that makes them so...\r\n"
  "	     *\r\n"
  "	     * WebSockets are supposedly using a ping/pong protocol to\r\n"
  "	     * motivate proxies to keep connections open, but we've never\r\n"
  "	     * seen a browser pinging us ?\r\n"
  "	     *\r\n"
  "	     * So, we ping pong ourselves.\r\n"
  "	     */\r\n"
  "	    if (connectionMonitor) {\r\n"
  "	      connectionMonitor.onStatusChange('websocket', true);\r\n"
  "	      connectionMonitor.onStatusChange('connectionStatus', 1);\r\n"
  "	    }\r\n"
  "\r\n"
  "	    /*\r\n"
  "	      ws.send('&signal=ping'); // to get our first onmessage\r\n"
  "	     */\r\n"
  "	    schedulePing();\r\n"
  "	  };\r\n"
  "	}\r\n"
  "      }\r\n"
  "\r\n"
  "      if ((ws.readyState == 1) && (ws.state == WebSocketWorking)) {\r\n"
  "	schedulePing();\r\n"
  "	sendUpdate();\r\n"
  "	return;\r\n"
  "      }\r\n"
  "    }\r\n"
  "  }\r\n"
  "_$_$endif_$_();\r\n"
  "\r\n"
  "  if (responsePending != null && pollTimer != null) {\r\n"
  "    clearTimeout(pollTimer);\r\n"
  "    pollTimer = null;\r\n"
  "    responsePending.abort();\r\n"
  "    responsePending = null;\r\n"
  "  }\r\n"
  "\r\n"
  "  if (responsePending == null) {\r\n"
  "    if (updateTimeout == null) {\r\n"
  "      updateTimeout = setTimeout(function() { sendUpdate(); }, WT.updateDelay);\r\n"
  "      updateTimeoutStart = (new Date).getTime();\r\n"
  "    } else if (commErrors) {\r\n"
  "      clearTimeout(updateTimeout);\r\n"
  "      updateTimeout = null;\r\n"
  "      sendUpdate();\r\n"
  "    } else {\r\n"
  "      var diff = (new Date).getTime() - updateTimeoutStart;\r\n"
  "      if (diff > WT.updateDelay) {\r\n"
  "	clearTimeout(updateTimeout);\r\n"
  "	updateTimeout = null;\r\n"
  "	sendUpdate();\r\n"
  "      }\r\n"
  "    }\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "var ackUpdateId = _$_ACK_UPDATE_ID_$_, ackPuzzle = null;\r\n"
  "function responseReceived(updateId, puzzle) {\r\n"
  "  ackPuzzle = puzzle;\r\n"
  "  ackUpdateId = updateId;\r\n"
  "  comm.responseReceived(updateId);\r\n"
  "}\r\n"
  "\r\n"
  "function wsRqsDone() {\r\n"
  "  for (var i = 0; i < arguments.length; ++i) {\r\n"
  "    var wsRqId = arguments[i];\r\n"
  "    if (wsRqId in pendingWsRequests) {\r\n"
  "      clearTimeout(pendingWsRequests[wsRqId].tm);\r\n"
  "      delete pendingWsRequests[wsRqId];\r\n"
  "    }\r\n"
  "  }\r\n"
  "  wsWaitFeedback();\r\n"
  "}\r\n"
  "\r\n"
  "var pageId = 0;\r\n"
  "function setPage(id) {\r\n"
  "  pageId = id;\r\n"
  "}\r\n"
  "\r\n"
  "function sendError(err, errMsg) {\r\n"
  "  responsePending = comm.sendUpdate\r\n"
  "    ('request=jserror&err=' + encodeURIComponent(JSON.stringify(err)),\r\n"
  "     false, ackUpdateId, -1);\r\n"
  "_$_$if_SHOW_ERROR_$_();\r\n"
  "  alert(errMsg);\r\n"
  "_$_$endif_$_();\r\n"
  "}\r\n"
  "\r\n"
  "function sendUpdate() {\r\n"
  "  if (self != window._$_APP_CLASS_$_) {\r\n"
  "    quit(null);\r\n"
  "    return;\r\n"
  "  }\r\n"
  "\r\n"
  "  if (responsePending)\r\n"
  "    return;\r\n"
  "\r\n"
  "  updateTimeout = null;\r\n"
  "  var feedback;\r\n"
  "\r\n"
  "  if (WT.isIEMobile) feedback = false;\r\n"
  "\r\n"
  "  if (hasQuit)\r\n"
  "    return;\r\n"
  "\r\n"
  "  var data, tm, poll;\r\n"
  "\r\n"
  "  var useWebSockets = websocket.socket !== null &&\r\n"
  "                      websocket.socket.readyState === 1 &&\r\n"
  "                      websocket.state === WebSocketWorking;\r\n"
  "\r\n"
  "  if (pendingEvents.length > 0) {\r\n"
  "    data = encodePendingEvents();\r\n"
  "    tm = data.feedback ? setTimeout(useWebSockets ? wsWaitFeedback : waitFeedback, _$_INDICATOR_TIMEOUT_$_)\r\n"
  "      : null;\r\n"
  "    poll = false;\r\n"
  "  } else {\r\n"
  "    data = {result: '&signal=poll' };\r\n"
  "    tm = null;\r\n"
  "    poll = true;\r\n"
  "  }\r\n"
  "\r\n"
  "  if (!useWebSockets) {\r\n"
  "    data.result += '&ackId=' + ackUpdateId;\r\n"
  "  }\r\n"
  "\r\n"
  "  data.result += '&pageId=' + pageId;\r\n"
  "\r\n"
  "  if (ackPuzzle) {\r\n"
  "    var solution = '';\r\n"
  "    var d = $('#' + ackPuzzle).get(0);\r\n"
  "    if (d) {\r\n"
  "      d = d.parentNode;\r\n"
  "\r\n"
  "      for (; !WT.hasTag(d, 'BODY'); d = d.parentNode) {\r\n"
  "	if (d.id) {\r\n"
  "	  if (solution != '') solution += ',';\r\n"
  "	  solution += d.id;\r\n"
  "	}\r\n"
  "      }\r\n"
  "    }\r\n"
  "\r\n"
  "    data.result += '&ackPuzzle=' + encodeURIComponent(solution);\r\n"
  "  }\r\n"
  "\r\n"
  "  function getParams() {\r\n"
  "    // Prevent minifier from optimizing away the length check.\r\n"
  "    return \"_$_PARAMS_$_\";\r\n"
  "  }\r\n"
  "  var params = getParams();\r\n"
  "  if (params.length > 0)\r\n"
  "    data.result += '&Wt-params=' + encodeURIComponent(params);\r\n"
  "\r\n"
  "  if (useWebSockets) {\r\n"
  "    responsePending = null;\r\n"
  "\r\n"
  "    if (!poll) {\r\n"
  "      if (tm) {\r\n"
  "	var wsRqId = nextWsRqId;\r\n"
  "	pendingWsRequests[wsRqId] = {time: Date.now(), tm: tm};\r\n"
  "	++nextWsRqId;\r\n"
  "	data.result += '&wsRqId=' + wsRqId;\r\n"
  "      }\r\n"
  "\r\n"
  "      websocket.socket.send(data.result);\r\n"
  "    }\r\n"
  "  } else {\r\n"
  "    if (responsePending) {\r\n"
  "      try {\r\n"
  "	throw new Error(\"responsePending is true before comm.sendUpdate\");\r\n"
  "      } catch (e) {\r\n"
  "	var stack = e.stack || e.stacktrace;\r\n"
  "	var description = e.description || e.message;\r\n"
  "	var err = { \"exception_description\" : description };\r\n"
  "	err.stack = stack;\r\n"
  "	sendError(err, \"Wt internal error; description: \" + description);\r\n"
  "	throw e;\r\n"
  "      }\r\n"
  "    }\r\n"
  "\r\n"
  "    pollTimer\r\n"
  "     = poll ? setTimeout(doPollTimeout, _$_SERVER_PUSH_TIMEOUT_$_) : null;\r\n"
  "\r\n"
  "    responsePending = 1;\r\n"
  "    responsePending = comm.sendUpdate\r\n"
  "      ('request=jsupdate' + data.result, tm, ackUpdateId, -1);\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "function propagateSize(element, width, height) {\r\n"
  "  /*\r\n"
  "   * Propagate the size, even if it's the elements unconstrained size.\r\n"
  "   */\r\n"
  "  if (width == -1)\r\n"
  "    width = element.offsetWidth;\r\n"
  "  if (height == -1)\r\n"
  "    height = element.offsetHeight;\r\n"
  "\r\n"
  "  if ((typeof element.wtWidth === UNDEFINED)\r\n"
  "      || (element.wtWidth != width)\r\n"
  "      || (typeof element.wtHeight === UNDEFINED)\r\n"
  "      || (element.wtHeight != height)) {\r\n"
  "    element.wtWidth = width;\r\n"
  "    element.wtHeight = height;\r\n"
  "\r\n"
  "    if (width >= 0 && height >= 0)\r\n"
  "      emit(element, 'resized', Math.round(width), Math.round(height));\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "function emit(object, config) {\r\n"
  "  var userEvent = new Object(), ei = pendingEvents.length;\r\n"
  "  userEvent.signal = \"user\";\r\n"
  "\r\n"
  "  if (typeof object === \"string\")\r\n"
  "    userEvent.id = object;\r\n"
  "  else if (object == self)\r\n"
  "    userEvent.id = \"app\";\r\n"
  "  else\r\n"
  "    userEvent.id = object.id;\r\n"
  "\r\n"
  "  if (typeof config === \"object\") {\r\n"
  "    userEvent.name = config.name;\r\n"
  "    userEvent.object = config.eventObject;\r\n"
  "    userEvent.event = config.event;\r\n"
  "  } else {\r\n"
  "    userEvent.name = config;\r\n"
  "    userEvent.object = userEvent.event = null;\r\n"
  "  }\r\n"
  "\r\n"
  "  userEvent.args = [];\r\n"
  "  for (var i = 2; i < arguments.length; ++i) {\r\n"
  "    var a = arguments[i], r;\r\n"
  "    if (a === false)\r\n"
  "      r = 0;\r\n"
  "    else if (a === true)\r\n"
  "      r = 1;\r\n"
  "    else if (a && a.toDateString)\r\n"
  "      r = a.toDateString();\r\n"
  "    else\r\n"
  "      r = a;\r\n"
  "    userEvent.args[i-2] = r;\r\n"
  "  }\r\n"
  "  userEvent.feedback = true;\r\n"
  "  userEvent.evAckId = ackUpdateId;\r\n"
  "\r\n"
  "  pendingEvents[ei] = encodeEvent(userEvent, ei);\r\n"
  "\r\n"
  "  scheduleUpdate();\r\n"
  "}\r\n"
  "\r\n"
  "function addTimerEvent(timerid, msec, repeat) {\r\n"
  "  var tm = function() {\r\n"
  "    var obj = WT.getElement(timerid);\r\n"
  "    if (obj) {\r\n"
  "      if (repeat != -1)\r\n"
  "	obj.timer = setTimeout(obj.tm, repeat);\r\n"
  "      else {\r\n"
  "	obj.timer = null;\r\n"
  "	obj.tm = null;\r\n"
  "      }\r\n"
  "      if (obj.onclick)\r\n"
  "	obj.onclick();\r\n"
  "    }\r\n"
  "  };\r\n"
  "  \r\n"
  "  var obj = WT.getElement(timerid);\r\n"
  "  if (obj.timer)\r\n"
  "    clearTimeout(obj.timer);\r\n"
  "  obj.timer = setTimeout(tm, msec);\r\n"
  "  obj.tm = tm;\r\n"
  "}\r\n"
  "\r\n"
  "var jsLibsLoaded = {};\r\n"
  "var waitingForJavaScript = false;\r\n"
  "\r\n"
  "function onJsLoad(path, f) {\r\n"
  "  // setTimeout needed for Opera\r\n"
  "  setTimeout(function() {\r\n"
  "    if (jsLibsLoaded[path] === true) {\r\n"
  "      waitingForJavaScript = false;\r\n"
  "      f();\r\n"
  "      if (!waitingForJavaScript && serverPush)\r\n"
  "        sendUpdate();\r\n"
  "    } else\r\n"
  "      jsLibsLoaded[path] = f;\r\n"
  "    }, 20);\r\n"
  "\r\n"
  "  waitingForJavaScript = true;\r\n"
  "};\r\n"
  "\r\n"
  "function jsLoaded(path)\r\n"
  "{\r\n"
  "  if (jsLibsLoaded[path] === true)\r\n"
  "    return;\r\n"
  "  else {\r\n"
  "    if (typeof jsLibsLoaded[path] !== UNDEFINED) {\r\n"
  "      waitingForJavaScript = false;\r\n"
  "      jsLibsLoaded[path]();\r\n"
  "      if (!waitingForJavaScript && serverPush)\r\n"
  "	sendUpdate();\r\n"
  "    }\r\n"
  "    jsLibsLoaded[path] = true;\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "function loadScript(uri, symbol, tries)\r\n"
  "{\r\n"
  "  var loaded = false, error = false;\r\n"
  "\r\n"
  "  function onerror() {\r\n"
  "    if (!loaded && !error) {\r\n"
  "      error = true;\r\n"
  "\r\n"
  "      var t = tries === undefined ? (WT.isIE ? 1 : 2) : tries;\r\n"
  "      if (t > 1) {\r\n"
  "	loadScript(uri, symbol, t - 1);\r\n"
  "      } else {\r\n"
  "	var err = {\r\n"
  "	  \"error-description\" : 'Fatal error: failed loading ' + uri\r\n"
  "	};\r\n"
  "	sendError(err, err[\"error-description\"]);\r\n"
  "	quit(null);\r\n"
  "      }     \r\n"
  "    }\r\n"
  "  }\r\n"
  "\r\n"
  "  function onload() {\r\n"
  "    if (!loaded && !error) {\r\n"
  "      loaded = true;\r\n"
  "      jsLoaded(uri);\r\n"
  "    }\r\n"
  "  }\r\n"
  "\r\n"
  "  if (symbol != \"\") {\r\n"
  "    try {\r\n"
  "      loaded = !eval(\"typeof \" + symbol + \" === 'undefined'\");\r\n"
  "    } catch (e) {\r\n"
  "      loaded = false;\r\n"
  "    }\r\n"
  "  }\r\n"
  "\r\n"
  "  if (!loaded) {\r\n"
  "    var s = document.createElement('script');\r\n"
  "    s.setAttribute('src', uri);\r\n"
  "    s.onload = onload;\r\n"
  "    s.onerror = onerror;\r\n"
  "    s.onreadystatechange = function() {\r\n"
  "      var rs = s.readyState;\r\n"
  "      if (rs == 'loaded') { // may still be 404 in IE<=8; too bad!\r\n"
  "	if (WT.isOpera || WT.isIE) {\r\n"
  "	  onload();\r\n"
  "	} else\r\n"
  "	  onerror();\r\n"
  "      } else if (rs == 'complete') {\r\n"
  "	onload();\r\n"
  "      }\r\n"
  "    };\r\n"
  "    var h = document.getElementsByTagName('head')[0];\r\n"
  "    h.appendChild(s);\r\n"
  "  } else {\r\n"
  "    jsLoaded(uri);\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "function ImagePreloader(uris, callback) {\r\n"
  "  this.callback = callback;\r\n"
  "  this.work = uris.length;\r\n"
  "  this.images = [];\r\n"
  "\r\n"
  "  if (uris.length == 0)\r\n"
  "    this.callback(this.images);\r\n"
  "  else\r\n"
  "    for (var i = 0; i < uris.length; i++)\r\n"
  "      this.preload(uris[i]);\r\n"
  "};\r\n"
  "\r\n"
  "ImagePreloader.prototype.preload = function(uri) {\r\n"
  "  var image = new Image;\r\n"
  "  this.images.push(image);\r\n"
  "  image.onload = ImagePreloader.prototype.onload;\r\n"
  "  image.onerror = ImagePreloader.prototype.onload;\r\n"
  "  image.onabort = ImagePreloader.prototype.onload;\r\n"
  "  image.imagePreloader = this;\r\n"
  "\r\n"
  "  image.src = uri;\r\n"
  "};\r\n"
  "\r\n"
  "ImagePreloader.prototype.onload = function() {\r\n"
  "  // Called from the image: this = the image\r\n"
  "  var preloader = this.imagePreloader;\r\n"
  "  if (--preloader.work == 0)\r\n"
  "    preloader.callback(preloader.images);\r\n"
  "};\r\n"
  "\r\n"
  "ImagePreloader.prototype.cancel = function() {\r\n"
  "  var images = this.images;\r\n"
  "  for (var i = 0; i < images.length; ++i) {\r\n"
  "    images[i].onload = function(){};\r\n"
  "    images[i].onerror = function(){};\r\n"
  "    images[i].onabort = function(){};\r\n"
  "  }\r\n"
  "  this.callback = function(){};\r\n"
  "};\r\n"
  "\r\n"
  "/////////////////////////////////////////////////////////////////////\r\n"
  "// TG: A binary Buffer preloader\r\n"
  "\r\n"
  "// Constructor, preloads the given uris and stores them in arrayBuffers[]\r\n"
  "function ArrayBufferPreloader(uris, callback) {\r\n"
  "  // init members\r\n"
  "  // callback, when everything is loaded\r\n"
  "  this.callback = callback;\r\n"
  "  // number of open requests\r\n"
  "  this.work = uris.length;\r\n"
  "  // resulting buffers\r\n"
  "  this.arrayBuffers = [];\r\n"
  "  \r\n"
  "  // if urls are missing, call callback without buffers\r\n"
  "  if (uris.length == 0)\r\n"
  "    callback(this.arrayBuffers);\r\n"
  "  else \r\n"
  "  {\r\n"
  "    // if uris are given, load them asynchronously\r\n"
  "    for (var i = 0; i < uris.length; i++)\r\n"
  "      this.preload(uris[i], i);\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "// preload function: downloads buffer at the given URI\r\n"
  "ArrayBufferPreloader.prototype.preload = function(uri, index) {\r\n"
  "  var xhr = new XMLHttpRequest();\r\n"
  "  // open the resource, send asynchronously (without waiting for answer)\r\n"
  "  xhr.open(\"GET\", uri, true);\r\n"
  "  xhr.responseType = \"arraybuffer\"; \r\n"
  "\r\n"
  "  // give xhr write access to array\r\n"
  "  xhr.arrayBuffers = this.arrayBuffers;\r\n"
  "  xhr.preloader = this;\r\n"
  "  xhr.index = index; // needed to maintain the mapping\r\n"
  "  xhr.uri = uri;\r\n"
  "\r\n"
  "  // behaviour when it was loaded-> redirect to ArrayBufferPreloader\r\n"
  "  xhr.onload = function(e) {\r\n"
  "\r\n"
  "    console.log(\"XHR load buffer \" + this.index + \" from uri \" + this.uri);\r\n"
  "\r\n"
  "    //this.arrayBuffers[this.index] = new Uint8Array(this.response);\r\n"
  "    this.arrayBuffers[this.index] = this.response;\r\n"
  "    this.preloader.afterLoad();\r\n"
  "  };\r\n"
  "\r\n"
  "  xhr.onerror = ArrayBufferPreloader.prototype.afterload;\r\n"
  "  xhr.onabort = ArrayBufferPreloader.prototype.afterload;\r\n"
  "\r\n"
  "  // actually start the query\r\n"
  "  xhr.send();\r\n"
  "};\r\n"
  "\r\n"
  "ArrayBufferPreloader.prototype.afterLoad = function() {\r\n"
  "  if (--this.work == 0)\r\n"
  "    // last request finished -> call callback\r\n"
  "    this.callback(this.arrayBuffers);\r\n"
  "};\r\n"
  "/////////////////////////////////////////////////////////////////////\r\n"
  "\r\n"
  "\r\n"
  "function enableInternalPaths(initialHash) {\r\n"
  "  currentHash = initialHash;\r\n"
  "  WT.history.register(initialHash, onHashChange);\r\n"
  "}\r\n"
  "\r\n"
  "// For use in FlashObject.js. In IE7, the alternative content is\r\n"
  "// not inserted in the DOM and when it is, it cannot contain JavaScript.\r\n"
  "// Through a hack in the style attribute, we do execute JS, but what we\r\n"
  "// can do there is limited. Hence this helper method.\r\n"
  "function ieAlternative(d)\r\n"
  "{\r\n"
  "  if (d.ieAlternativeExecuted) return '0';\r\n"
  "  self.emit(d.parentNode, 'IeAlternative');\r\n"
  "  d.style.width = '';\r\n"
  "  d.ieAlternativeExecuted = true;\r\n"
  "  return '0';\r\n"
  "}\r\n"
  "\r\n"
  "window.onunload = function()\r\n"
  "{\r\n"
  "  if (!hasQuit) {\r\n"
  "    self.emit(self, \"Wt-unload\");\r\n"
  "    scheduleUpdate();\r\n"
  "    sendUpdate();\r\n"
  "  }\r\n"
  "};\r\n"
  "\r\n"
  "function setLocale(m)\r\n"
  "{	\r\n"
  "  if (WT.isIEMobile || m == '') return;\r\n"
  "  document.documentElement.lang = m\r\n"
  "}\r\n"
  "\r\n"
  "function setCloseMessage(m)\r\n"
  "{\r\n"
  "  if (m && m != '') {\r\n"
  "    window.onbeforeunload = function(event) {\r\n"
  "      var e = event || window.event;\r\n"
  "\r\n"
  "      if (e)\r\n"
  "	e.returnValue = m;\r\n"
  "\r\n"
  "      return m;\r\n"
  "    };\r\n"
  "  } else\r\n"
  "    window.onbeforeunload = null;\r\n"
  "};\r\n"
  "\r\n"
  "var firstCall = true;\r\n"
  "var globalEventsFunctions = null;\r\n"
  "var keyEvents = [ 'keydown', 'keyup', 'keypress' ];\r\n"
  "\r\n"
  "function updateGlobal(id) {\r\n"
  "  firstCall = false;\r\n"
  "  var domId;\r\n"
  "  if (id == null) {\r\n"
  "    domId = $('.Wt-domRoot').get(0).id\r\n"
  "  } else {\r\n"
  "    domId = id;\r\n"
  "  }\r\n"
  "\r\n"
  "  for (var i = 0; i < keyEvents.length ; ++i) {\r\n"
  "    var elemEvents = globalEventsFunctions ? globalEventsFunctions[domId] : null;\r\n"
  "    var eventFunc = null;\r\n"
  "\r\n"
  "    if (elemEvents) \r\n"
  "      eventFunc = elemEvents[keyEvents[i]];\r\n"
  "\r\n"
  "    var bindEvent = function(evtfunc) {\r\n"
  "      return function(event) {\r\n"
  "	var g=event||window.event;\r\n"
  "	var t=g.target||g.srcElement;\r\n"
  "	if ((!t| WT.hasTag(t,'DIV')\r\n"
  "	  || WT.hasTag(t,'BODY')\r\n"
  "	    || WT.hasTag(t,'HTML'))) {\r\n"
  "	      var func = evtfunc;\r\n"
  "	      if(func)\r\n"
  "		func(event);\r\n"
  "	    }\r\n"
  "      };\r\n"
  "    };\r\n"
  "\r\n"
  "    if (eventFunc)\r\n"
  "      document['on' + keyEvents[i] ] = bindEvent(eventFunc);\r\n"
  "    else \r\n"
  "      document['on' + keyEvents[i] ] = null;\r\n"
  "\r\n"
  "  }\r\n"
  "\r\n"
  "  // cleanup functions of widgets that do no longer exist\r\n"
  "  if (globalEventsFunctions) {\r\n"
  "    for (var i in globalEventsFunctions) {\r\n"
  "      if (!document.getElementById(i)) {\r\n"
  "	delete globalEventsFunctions[i];\r\n"
  "      }\r\n"
  "    }\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "function bindGlobal(event, id, f) {\r\n"
  "  var init = false;\r\n"
  "  if (!globalEventsFunctions) {\r\n"
  "    globalEventsFunctions = {};\r\n"
  "    init = true;\r\n"
  "  }\r\n"
  "\r\n"
  "  // Saves the event functions\r\n"
  "  if (!globalEventsFunctions[id])\r\n"
  "    globalEventsFunctions[id] = {};\r\n"
  "\r\n"
  "  globalEventsFunctions[id][event]=f;\r\n"
  "  if(init)\r\n"
  "    setTimeout(function() {\r\n"
  "      if(firstCall)\r\n"
  "	updateGlobal(null);\r\n"
  "    }, 0);\r\n"
  "}\r\n"
  "\r\n"
  "function refreshMultiSessionCookie() {\r\n"
  "  comm.sendUpdate('request=jsupdate&signal=keepAlive&ackId=' + ackUpdateId, false, ackUpdateId, -1);\r\n"
  "}\r\n"
  "\r\n"
  "var googleMapsLoaded = false;\r\n"
  "var googleMapsLoadedCallbacks = [];\r\n"
  "\r\n"
  "function loadGoogleMaps(version, key, callback) {\r\n"
  "  if (googleMapsLoaded) {\r\n"
  "    callback();\r\n"
  "  } else {\r\n"
  "    googleMapsLoadedCallbacks.push(callback);\r\n"
  "    if (googleMapsLoadedCallbacks.length === 1) {\r\n"
  "      google.load(\"maps\", version, {\r\n"
  "        other_params: \"key=\" + key,\r\n"
  "        callback: function() {\r\n"
  "          googleMapsLoaded = true;\r\n"
  "          for (var i = 0; i < googleMapsLoadedCallbacks.length; ++i) {\r\n"
  "            googleMapsLoadedCallbacks[i]();\r\n"
  "          }\r\n"
  "          googleMapsLoadedCallbacks = [];\r\n"
  "        }\r\n"
  "      });\r\n"
  "    }\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "this._p_ = {\r\n"
  "  ieAlternative : ieAlternative,\r\n"
  "  loadScript : loadScript,\r\n"
  "  onJsLoad : onJsLoad,\r\n"
  "  setTitle : setTitle,\r\n"
  "  setLocale : setLocale,\r\n"
  "  update : update,\r\n"
  "  quit : quit,\r\n"
  "  setSessionUrl : setSessionUrl,\r\n"
  "  setFormObjects : function(o) { formObjects = o; },\r\n"
  "  saveDownPos : saveDownPos,\r\n"
  "  addTimerEvent : addTimerEvent,\r\n"
  "  load : load,\r\n"
  "  setServerPush : setServerPush,\r\n"
  "\r\n"
  "  touchStart :touchStart,\r\n"
  "  touchEnded: touchEnded,\r\n"
  "  dragStart : dragStart,\r\n"
  "  dragDrag : dragDrag,\r\n"
  "  dragEnd : dragEnd,\r\n"
  "  capture : WT.capture,\r\n"
  "\r\n"
  "  enableInternalPaths : enableInternalPaths,\r\n"
  "  onHashChange : onHashChange,\r\n"
  "  setHash : setHash,\r\n"
  "  ImagePreloader : ImagePreloader,  \r\n"
  "  ArrayBufferPreloader : ArrayBufferPreloader,\r\n"
  "  \r\n"
  "  doAutoJavaScript : doAutoJavaScript,\r\n"
  "  autoJavaScript : function() { },\r\n"
  "\r\n"
  "  response : responseReceived,\r\n"
  "  wsRqsDone : wsRqsDone,\r\n"
  "  setPage : setPage,\r\n"
  "  setCloseMessage : setCloseMessage,\r\n"
  "  setConnectionMonitor : setConnectionMonitor,\r\n"
  "  updateGlobal: updateGlobal,\r\n"
  "  bindGlobal: bindGlobal,\r\n"
  "  refreshCookie: refreshMultiSessionCookie,\r\n"
  "\r\n"
  "  propagateSize : propagateSize,\r\n"
  "\r\n"
  "  loadGoogleMaps : loadGoogleMaps\r\n"
  "};\r\n"
  "\r\n"
  "this.WT = _$_WT_CLASS_$_;\r\n"
  "this.emit = emit;\r\n"
  "\r\n"
  "})();\r\n"
  "\r\n"
  "window._$_APP_CLASS_$_SignalEmit = _$_APP_CLASS_$_.emit;\r\n"
  "\r\n"
  "window._$_APP_CLASS_$_OnLoad = function() {\r\n"
  "  _$_APP_CLASS_$_._p_.load();\r\n"
  "};\r\n"
  "";
  std::vector<const char *> Wt_js()
  {
    std::vector<const char *> retval;

    retval.push_back(Wt_js1);

    retval.push_back(Wt_js2);

    return retval;
  }
}